<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小莫的博客-fighting(技术分享、生活随笔)</title>
  
  <subtitle>行百里者半九十</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.xiaomo.info/"/>
  <updated>2020-06-28T16:53:07.143Z</updated>
  <id>https://blog.xiaomo.info/</id>
  
  <author>
    <name>小莫</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>unity常见面试题</title>
    <link href="https://blog.xiaomo.info/2020/unityInterviewQuestions/"/>
    <id>https://blog.xiaomo.info/2020/unityInterviewQuestions/</id>
    <published>2020-01-07T00:00:00.000Z</published>
    <updated>2020-06-28T16:53:07.143Z</updated>
    
    <content type="html"><![CDATA[<p>算起来到现在为止面试的大多是游戏服务端或者web前端相关的类容，没有经历过一次正儿八经的Unity面试，通过面试题也可以侧面了解到Unity开发中有哪些常用的需要掌握的知识，因此搬运一篇号称“屎上最全”的博客当作备份。<br><a id="more"></a></p><h3 id="一．什么是渲染管道？"><a href="#一．什么是渲染管道？" class="headerlink" title="一．什么是渲染管道？"></a>一．什么是渲染管道？</h3><p>是指在显示器上为了显示出图像而经过的一系列必要操作。<br>渲染管道中的很多步骤，都要将几何物体从一个坐标系中变换到另一个坐标系中去。<br>主要步骤有：<br>本地坐标-&gt;视图坐标-&gt;背面裁剪-&gt;光照-&gt;裁剪-&gt;投影-&gt;视图变换-&gt;光栅化。</p><h3 id="二．如何优化内存？"><a href="#二．如何优化内存？" class="headerlink" title="二．如何优化内存？"></a>二．如何优化内存？</h3><p>有很多种方式，例如</p><ul><li>1.压缩自带类库；</li><li>2.将暂时不用的以后还需要使用的物体隐藏起来而不是直接Destroy掉；</li><li>3.释放AssetBundle占用的资源；</li><li>4.降低模型的片面数，降低模型的骨骼数量，降低贴图的大小；</li><li>5.使用光照贴图，使用多层次细节(LOD)，使用着色器(Shader)，使用预设(Prefab)。</li></ul><h3 id="三、动态加载资源的方式？-有时候也问区别，具体请百度"><a href="#三、动态加载资源的方式？-有时候也问区别，具体请百度" class="headerlink" title="三、动态加载资源的方式？(有时候也问区别，具体请百度)"></a>三、动态加载资源的方式？(有时候也问区别，具体请百度)</h3><ul><li>1.Resources.Load();</li><li>2.AssetBundle</li></ul><h3 id="四：什么是协同程序？"><a href="#四：什么是协同程序？" class="headerlink" title="四：什么是协同程序？"></a>四：什么是协同程序？</h3><p>在主线程运行的同时开启另一段逻辑处理，来协助当前程序的执行，协程很像多线程，但是不是多线程，Unity的协程实在每帧结束之后去检测yield的条件是否满足。<br>五：Unity3d中的碰撞器和触发器的区别？</p><p>碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性。当Is Trigger=false时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter/Stay/Exit函数；当Is Trigger=true时，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用OnTriggerEnter/Stay/Exit函数。如果既要检测到物体的接触又不想让碰撞检测影响物体移动或要检测一个物件是否经过空间中的某个区域这时就可以用到触发器</p><h3 id="六：物体发生碰撞的必要条件？"><a href="#六：物体发生碰撞的必要条件？" class="headerlink" title="六：物体发生碰撞的必要条件？"></a>六：物体发生碰撞的必要条件？</h3><p>两个物体都必须带有碰撞器（Collider），其中一个物体还必须带有Rigidbody刚体，而且必须是运动的物体带有Rigidbody脚本才能检测到碰撞。</p><h3 id="七：请简述ArrayList和List的主要区别？"><a href="#七：请简述ArrayList和List的主要区别？" class="headerlink" title="七：请简述ArrayList和List的主要区别？"></a>七：请简述ArrayList和List的主要区别？</h3><p>ArrayList存在不安全类型（ArrayList会把所有插入其中的数据都当做Object来处理） 装箱拆箱的操作（费时） List是接口，ArrayList是一个实现了该接口的类，可以被实例化</p><h3 id="八：如何安全的在不同工程间安全地迁移asset数据？三种方法"><a href="#八：如何安全的在不同工程间安全地迁移asset数据？三种方法" class="headerlink" title="八：如何安全的在不同工程间安全地迁移asset数据？三种方法"></a>八：如何安全的在不同工程间安全地迁移asset数据？三种方法</h3><ul><li>1.将Assets目录和Library目录一起迁移</li><li>2.导出包，export Package</li><li>3.用unity自带的assets Server功能</li></ul><h3 id="九：OnEnable、Awake、Start运行时的发生顺序？哪些可能在同一个对象周期中反复的发生"><a href="#九：OnEnable、Awake、Start运行时的发生顺序？哪些可能在同一个对象周期中反复的发生" class="headerlink" title="九：OnEnable、Awake、Start运行时的发生顺序？哪些可能在同一个对象周期中反复的发生"></a>九：OnEnable、Awake、Start运行时的发生顺序？哪些可能在同一个对象周期中反复的发生</h3><p>Awake –&gt;OnEnable-&gt;Start，OnEnable在同一周期中可以反复地发生。</p><h3 id="十：MeshRender中material和sharedmaterial的区别？"><a href="#十：MeshRender中material和sharedmaterial的区别？" class="headerlink" title="十：MeshRender中material和sharedmaterial的区别？"></a>十：MeshRender中material和sharedmaterial的区别？</h3><p>修改sharedMaterial将改变所有物体使用这个材质的外观，并且也改变储存在工程里的材质设置。不推荐修改由sharedMaterial返回的材质。如果你想修改渲染器的材质，使用material替代。</p><h3 id="十一：Unity提供了几种光源，分别是什么"><a href="#十一：Unity提供了几种光源，分别是什么" class="headerlink" title="十一：Unity提供了几种光源，分别是什么"></a>十一：Unity提供了几种光源，分别是什么</h3><p>四种。</p><ul><li>平行光：Directional Light</li><li>点光源：Point Light</li><li>聚光灯：Spot Light</li><li>区域光源：Area Light</li></ul><h3 id="十二：简述一下对象池，你觉得在FPS里哪些东西适合使用对象池"><a href="#十二：简述一下对象池，你觉得在FPS里哪些东西适合使用对象池" class="headerlink" title="十二：简述一下对象池，你觉得在FPS里哪些东西适合使用对象池"></a>十二：简述一下对象池，你觉得在FPS里哪些东西适合使用对象池</h3><p>对象池就存放需要被反复调用资源的一个空间，当一个对象回大量生成的时候如果每次都销毁创建会很费时间，通过对象池把暂时不用的对象放到一个池中（也就是一个集合），当下次要重新生成这个对象的时候先去池中查找一下是否有可用的对象，如果有的话就直接拿出来使用，不需要再创建，如果池中没有可用的对象，才需要重新创建，利用空间换时间来达到游戏的高速运行效果，在FPS游戏中要常被大量复制的对象包括子弹，敌人，粒子等</p><h3 id="十三：CharacterController和Rigidbody的区别"><a href="#十三：CharacterController和Rigidbody的区别" class="headerlink" title="十三：CharacterController和Rigidbody的区别"></a>十三：CharacterController和Rigidbody的区别</h3><p>Rigidbody具有完全真实物理的特性，Unity中物理系统最基本的一个组件，包含了常用的物理特性，而CharacterController可以说是受限的的Rigidbody，具有一定的物理效果但不是完全真实的，是Unity为了使开发者能方便的开发第一人称视角的游戏而封装的一个组件</p><h3 id="十四：简述prefab的用处"><a href="#十四：简述prefab的用处" class="headerlink" title="十四：简述prefab的用处"></a>十四：简述prefab的用处</h3><p>在游戏运行时实例化，prefab相当于一个模板，对你已经有的素材、脚本、参数做一个默认的配置，以便于以后的修改，同时prefab打包的内容简化了导出的操作，便于团队的交流。</p><h3 id="十五：请简述sealed关键字用在类声明时与函数声明时的作用"><a href="#十五：请简述sealed关键字用在类声明时与函数声明时的作用" class="headerlink" title="十五：请简述sealed关键字用在类声明时与函数声明时的作用"></a>十五：请简述sealed关键字用在类声明时与函数声明时的作用</h3><p>sealed修饰的类为密封类，类声明时可防止其他类继承此类，在方法中声明则可防止派生类重写此方法。</p><h3 id="十六：请简述private，public，protected，internal的区别"><a href="#十六：请简述private，public，protected，internal的区别" class="headerlink" title="十六：请简述private，public，protected，internal的区别"></a>十六：请简述private，public，protected，internal的区别</h3><ul><li>public：对任何类和成员都公开，无限制访问</li><li>private：仅对该类公开</li><li>protected：对该类和其派生类公开</li><li>internal：只能在包含该类的程序集中访问该类</li></ul><h3 id="十七：使用Unity3d实现2d游戏，有几种方式？"><a href="#十七：使用Unity3d实现2d游戏，有几种方式？" class="headerlink" title="十七：使用Unity3d实现2d游戏，有几种方式？"></a>十七：使用Unity3d实现2d游戏，有几种方式？</h3><ul><li>1.使用本身的GUI，在Unity4.6以后出现的UGUI</li><li>2.把摄像机的Projection(投影)值调为Orthographic(正交投影)，不考虑z轴；</li><li>3.使用2d插件，如：2DToolKit，和NGUI</li></ul><h3 id="十八：在物体发生碰撞的整个过程中，有几个阶段，分别列出对应的函数"><a href="#十八：在物体发生碰撞的整个过程中，有几个阶段，分别列出对应的函数" class="headerlink" title="十八：在物体发生碰撞的整个过程中，有几个阶段，分别列出对应的函数"></a>十八：在物体发生碰撞的整个过程中，有几个阶段，分别列出对应的函数</h3><p>三个阶段，1.OnCollisionEnter 2.OnCollisionStay 3.OnCollisionExit</p><h3 id="十九：Unity3d的物理引擎中，有几种施加力的方式，分别描述出来"><a href="#十九：Unity3d的物理引擎中，有几种施加力的方式，分别描述出来" class="headerlink" title="十九：Unity3d的物理引擎中，有几种施加力的方式，分别描述出来"></a>十九：Unity3d的物理引擎中，有几种施加力的方式，分别描述出来</h3><p>rigidbody.AddForce/AddForceAtPosition，都在rigidbody系列函数中。大家可以自己去查看一下rigidbody的API</p><h3 id="二十：什么叫做链条关节？"><a href="#二十：什么叫做链条关节？" class="headerlink" title="二十：什么叫做链条关节？"></a>二十：什么叫做链条关节？</h3><p>Hinge Joint，可以模拟两个物体间用一根链条连接在一起的情况，能保持两个物体在一个固定距离内部相互移动而不产生作用力，但是达到固定距离后就会产生拉力。</p><h3 id="二十一：物体自身旋转使用的函数？"><a href="#二十一：物体自身旋转使用的函数？" class="headerlink" title="二十一：物体自身旋转使用的函数？"></a>二十一：物体自身旋转使用的函数？</h3><p>Transform.Rotate()</p><h3 id="二十二：Unity3d提供了一个用于保存和读取数据的类-PlayerPrefs-，请列出保存和读取整形数据的函数"><a href="#二十二：Unity3d提供了一个用于保存和读取数据的类-PlayerPrefs-，请列出保存和读取整形数据的函数" class="headerlink" title="二十二：Unity3d提供了一个用于保存和读取数据的类(PlayerPrefs)，请列出保存和读取整形数据的函数"></a>二十二：Unity3d提供了一个用于保存和读取数据的类(PlayerPrefs)，请列出保存和读取整形数据的函数</h3><p>PlayerPrefs.SetInt() PlayerPrefs.GetInt()</p><h3 id="二十三：Unity3d脚本从唤醒到销毁有着一套比较完整的生命周期，请列出系统自带的几个重要的方法。"><a href="#二十三：Unity3d脚本从唤醒到销毁有着一套比较完整的生命周期，请列出系统自带的几个重要的方法。" class="headerlink" title="二十三：Unity3d脚本从唤醒到销毁有着一套比较完整的生命周期，请列出系统自带的几个重要的方法。"></a>二十三：Unity3d脚本从唤醒到销毁有着一套比较完整的生命周期，请列出系统自带的几个重要的方法。</h3><p>Awake——&gt;OnEnable–&gt;Start——&gt;Update——&gt;FixedUpdate——&gt;LateUpdate——&gt;OnGUI——&gt;OnDisable——&gt;OnDestroy</p><h3 id="二十四：物理更新一般放在哪个系统函数里？"><a href="#二十四：物理更新一般放在哪个系统函数里？" class="headerlink" title="二十四：物理更新一般放在哪个系统函数里？"></a>二十四：物理更新一般放在哪个系统函数里？</h3><p>FixedUpdate，每固定帧绘制时执行一次，和Update不同的是FixedUpdate是渲染帧执行，如果你的渲染效率低下的时候FixedUpdate调用次数就会跟着下降。FixedUpdate比较适用于物理引擎的计算，因为是跟每帧渲染有关。Update就比较适合做控制。</p><h3 id="二十五：在场景中放置多个Camera并同时处于活动状态会发生什么？"><a href="#二十五：在场景中放置多个Camera并同时处于活动状态会发生什么？" class="headerlink" title="二十五：在场景中放置多个Camera并同时处于活动状态会发生什么？"></a>二十五：在场景中放置多个Camera并同时处于活动状态会发生什么？</h3><p>游戏界面可以看到很多摄像机的混合。</p><h3 id="二十六：如何销毁一个UnityEngine-Object及其子类？"><a href="#二十六：如何销毁一个UnityEngine-Object及其子类？" class="headerlink" title="二十六：如何销毁一个UnityEngine.Object及其子类？"></a>二十六：如何销毁一个UnityEngine.Object及其子类？</h3><p>使用Destroy()方法;</p><h3 id="二十七：请描述为什么Unity3d中会发生在组件上出现数据丢失的情况"><a href="#二十七：请描述为什么Unity3d中会发生在组件上出现数据丢失的情况" class="headerlink" title="二十七：请描述为什么Unity3d中会发生在组件上出现数据丢失的情况"></a>二十七：请描述为什么Unity3d中会发生在组件上出现数据丢失的情况</h3><p>一般是组件上绑定的物体对象被删除了</p><h3 id="二十八：LOD是什么，优缺点是什么？"><a href="#二十八：LOD是什么，优缺点是什么？" class="headerlink" title="二十八：LOD是什么，优缺点是什么？"></a>二十八：LOD是什么，优缺点是什么？</h3><p>LOD(Level of detail)多层次细节，是最常用的游戏优化技术。它按照模型的位置和重要程度决定物体渲染的资源分配，降低非重要物体的面数和细节度，从而获得高效率的渲染运算。缺点是增加了内存。</p><h3 id="二十九：MipMap是什么，作用？"><a href="#二十九：MipMap是什么，作用？" class="headerlink" title="二十九：MipMap是什么，作用？"></a>二十九：MipMap是什么，作用？</h3><p>MipMapping：在三维计算机图形的贴图渲染中有常用的技术，为加快渲染进度和减少图像锯齿，贴图被处理成由一系列被预先计算和优化过的图片组成的文件，这样的贴图被称为MipMap。</p><h3 id="三十：请描述Interface与抽象类之间的不同"><a href="#三十：请描述Interface与抽象类之间的不同" class="headerlink" title="三十：请描述Interface与抽象类之间的不同"></a>三十：请描述Interface与抽象类之间的不同</h3><p>抽象类表示该类中可能已经有一些方法的具体定义，但接口就是公公只能定义各个方法的界面 ，不能具体的实现代码在成员方法中。类是子类用来继承的，当父类已经有实际功能的方法时该方法在子类中可以不必实现，直接引用父类的方法，子类也可以重写该父类的方法。实现接口的时候必须要实现接口中所有的方法，不能遗漏任何一个。</p><h3 id="三十一：-Net与Mono的关系？"><a href="#三十一：-Net与Mono的关系？" class="headerlink" title="三十一：.Net与Mono的关系？"></a>三十一：.Net与Mono的关系？</h3><p>mono是.net的一个开源跨平台工具，就类似java虚拟机，java本身不是跨平台语言，但运行在虚拟机上就能够实现了跨平台。.net只能在windows下运行，mono可以实现跨平台跑，可以运行于linux，Unix，Mac OS等。</p><h3 id="三十二：简述Unity3D支持的作为脚本的语言的名称"><a href="#三十二：简述Unity3D支持的作为脚本的语言的名称" class="headerlink" title="三十二：简述Unity3D支持的作为脚本的语言的名称"></a>三十二：简述Unity3D支持的作为脚本的语言的名称</h3><p>Unity的脚本语言基于Mono的.Net平台上运行，可以使用.NET库，这也为XML、数据库、正则表达式等问题提供了很好的解决方案。Unity里的脚本都会经过编译，他们的运行速度也很快。这三种语言实际上的功能和运行速度是一样的，区别主要体现在语言特性上。JavaScript、 C#、Boo</p><h3 id="三十三：U3D中用于记录节点空间几何信息的组件名称，及其父类名称"><a href="#三十三：U3D中用于记录节点空间几何信息的组件名称，及其父类名称" class="headerlink" title="三十三：U3D中用于记录节点空间几何信息的组件名称，及其父类名称"></a>三十三：U3D中用于记录节点空间几何信息的组件名称，及其父类名称</h3><p>Transform 父类是 Component</p><h3 id="三十四：向量的点乘、叉乘以及归一化的意义？"><a href="#三十四：向量的点乘、叉乘以及归一化的意义？" class="headerlink" title="三十四：向量的点乘、叉乘以及归一化的意义？"></a>三十四：向量的点乘、叉乘以及归一化的意义？</h3><ul><li>1.点乘描述了两个向量的相似程度，结果越大两向量越相似，还可表示投影</li><li>2.叉乘得到的向量垂直于原来的两个向量</li><li>3.标准化向量：用在只关系方向，不关心大小的时候<h3 id="三十五：为何大家都在移动设备上寻求U3D原生GUI的替代方案"><a href="#三十五：为何大家都在移动设备上寻求U3D原生GUI的替代方案" class="headerlink" title="三十五：为何大家都在移动设备上寻求U3D原生GUI的替代方案"></a>三十五：为何大家都在移动设备上寻求U3D原生GUI的替代方案</h3>不美观，OnGUI很耗费时间，效率不高，使用不方便</li></ul><h3 id="三十六：请简述如何在不同分辨率下保持UI的一致性"><a href="#三十六：请简述如何在不同分辨率下保持UI的一致性" class="headerlink" title="三十六：请简述如何在不同分辨率下保持UI的一致性"></a>三十六：请简述如何在不同分辨率下保持UI的一致性</h3><p>NGUI很好的解决了这一点，屏幕分辨率的自适应性，原理就是计算出屏幕的宽高比跟原来的预设的屏幕分辨率求出一个对比值，然后修改摄像机的size。UGUI通过锚点和中心点和分辨率也解决这个问题</p><h3 id="三十七：什么是LightMap？"><a href="#三十七：什么是LightMap？" class="headerlink" title="三十七：什么是LightMap？"></a>三十七：什么是LightMap？</h3><p>LightMap:就是指在三维软件里实现打好光，然后渲染把场景各表面的光照输出到贴图上，最后又通过引擎贴到场景上，这样就使物体有了光照的感觉。</p><h3 id="三十八：Unity和cocos2d的区别"><a href="#三十八：Unity和cocos2d的区别" class="headerlink" title="三十八：Unity和cocos2d的区别"></a>三十八：Unity和cocos2d的区别</h3><ul><li><ol><li>Unity3D支持C#、javascript等，cocos2d-x 支持c++、Html5、Lua等。</li></ol></li><li><ol start="2"><li>cocos2d 开源 并且免费</li></ol></li><li><ol start="3"><li>Unity3D支持iOS、Android、Flash、Windows、Mac、Wii等平台的游戏开发，cocos2d-x支持iOS、Android、WP等。</li></ol></li></ul><h3 id="三十九：C-和C-的区别？"><a href="#三十九：C-和C-的区别？" class="headerlink" title="三十九：C#和C++的区别？"></a>三十九：C#和C++的区别？</h3><p>简单的说：C### 与C++ 比较的话，最重要的特性就是C### 是一种完全面向对象的语言，而C++ 不是，另外C### 是基于IL 中间语言和.NET Framework CLR 的，在可移植性，可维护性和强壮性都比C++ 有很大的改进。C### 的设计目标是用来开发快速稳定可扩展的应用程序，当然也可以通过Interop 和Pinvoke 完成一些底层操作。更详细的区别大家可以参考这里</p><h3 id="四十：结构体和类有何区别？"><a href="#四十：结构体和类有何区别？" class="headerlink" title="四十：结构体和类有何区别？"></a>四十：结构体和类有何区别？</h3><p>结构体是一种值类型，而类是引用类型。（值类型、引用类型是根据数据存储的角度来分的）就是值类型用于存储数据的值，引用类型用于存储对实际数据的引用。那么结构体就是当成值来使用的，类则通过引用来对实际数据操作</p><h3 id="四十一：ref参数和out参数是什么？有什么区别？"><a href="#四十一：ref参数和out参数是什么？有什么区别？" class="headerlink" title="四十一：ref参数和out参数是什么？有什么区别？"></a>四十一：ref参数和out参数是什么？有什么区别？</h3><p>ref和out参数的效果一样，都是通过关键字找到定义在主函数里面的变量的内存地址，并通过方法体内的语法改变它的大小。不同点就是输出参数必须对参数进行初始化。ref必须初始化，out 参数必须在函数里赋值。ref参数是引用，out参数为输出参数。</p><h3 id="四十二：C-的委托是什么？有何用处？"><a href="#四十二：C-的委托是什么？有何用处？" class="headerlink" title="四十二：C#的委托是什么？有何用处？"></a>四十二：C#的委托是什么？有何用处？</h3><p>委托类似于一种安全的指针引用，在使用它时是当做类来看待而不是一个方法，相当于对一组方法的列表的引用。用处：使用委托使程序员可以将方法引用封装在委托对象内。然后可以将该委托对象传递给可调用所引用方法的代码，而不必在编译时知道将调用哪个方法。与C或C++中的函数指针不同，委托是面向对象，而且是类型安全的。</p><h3 id="四十三：C-中的排序方式有哪些？"><a href="#四十三：C-中的排序方式有哪些？" class="headerlink" title="四十三：C#中的排序方式有哪些？"></a>四十三：C#中的排序方式有哪些？</h3><p>选择排序，冒泡排序，快速排序，插入排序，希尔排序，归并排序</p><h3 id="四十四：射线检测碰撞物的原理是？"><a href="#四十四：射线检测碰撞物的原理是？" class="headerlink" title="四十四：射线检测碰撞物的原理是？"></a>四十四：射线检测碰撞物的原理是？</h3><p>射线是3D世界中一个点向一个方向发射的一条无终点的线，在发射轨迹中与其他物体发生碰撞时，它将停止发射 。</p><h3 id="四十五：Unity中，照相机的Clipping-Planes的作用是什么？调整Near、Fare两个值时，应该注意什么？"><a href="#四十五：Unity中，照相机的Clipping-Planes的作用是什么？调整Near、Fare两个值时，应该注意什么？" class="headerlink" title="四十五：Unity中，照相机的Clipping Planes的作用是什么？调整Near、Fare两个值时，应该注意什么？"></a>四十五：Unity中，照相机的Clipping Planes的作用是什么？调整Near、Fare两个值时，应该注意什么？</h3><p>剪裁平面 。从相机到开始渲染和停止渲染之间的距离。</p><h3 id="四十六：如何让已经存在的GameObject在LoadLevel后不被卸载掉？"><a href="#四十六：如何让已经存在的GameObject在LoadLevel后不被卸载掉？" class="headerlink" title="四十六：如何让已经存在的GameObject在LoadLevel后不被卸载掉？"></a>四十六：如何让已经存在的GameObject在LoadLevel后不被卸载掉？</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DontDestroyOnLoad(transform.gameObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四十七：请简述GC（垃圾回收）产生的原因，并描述如何避免？"><a href="#四十七：请简述GC（垃圾回收）产生的原因，并描述如何避免？" class="headerlink" title="四十七：请简述GC（垃圾回收）产生的原因，并描述如何避免？"></a>四十七：请简述GC（垃圾回收）产生的原因，并描述如何避免？</h3><p>GC回收堆上的内存<br>避免：</p><ul><li>1.减少new产生对象的次数</li><li>2.使用公用的对象（静态成员）</li><li>3.将String换为StringBuilder</li></ul><h3 id="四十八：反射的实现原理？"><a href="#四十八：反射的实现原理？" class="headerlink" title="四十八：反射的实现原理？"></a>四十八：反射的实现原理？</h3><p>审查元数据并收集关于它的类型信息的能力。实现原理：在运行时根据程序集及其中的类型得到元数据。下面是实现步骤：</p><ol><li>导入using System.Reflection;</li><li>Assembly.Load(“程序集”)加载程序集,返回类型是一个Assembly</li><li>得到程序集中所有类的名称</li></ol><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (Type<span class="built_in"> type </span><span class="keyword">in</span> assembly.GetTypes())</span><br><span class="line">&#123;</span><br><span class="line">    string t = type.Name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>Type type = assembly.GetType(“程序集.类名”);获取当前类的类型</li><li>Activator.CreateInstance(type); 创建此类型实例</li><li>MethodInfo mInfo = type.GetMethod(“方法名”);获取当前方法</li><li>m.Info.Invoke(null,方法参数);</li></ol><h3 id="四十九：简述四元数的作用，四元数对欧拉角的优点？"><a href="#四十九：简述四元数的作用，四元数对欧拉角的优点？" class="headerlink" title="四十九：简述四元数的作用，四元数对欧拉角的优点？"></a>四十九：简述四元数的作用，四元数对欧拉角的优点？</h3><p>四元数用于表示旋转<br>相对欧拉角的优点：<br>1.能进行增量旋转<br>2.避免万向锁<br>3.给定方位的表达方式有两种，互为负（欧拉角有无数种表达方式）</p><h3 id="五十：移动相机动作在哪个函数里，为什么在这个函数里？"><a href="#五十：移动相机动作在哪个函数里，为什么在这个函数里？" class="headerlink" title="五十：移动相机动作在哪个函数里，为什么在这个函数里？"></a>五十：移动相机动作在哪个函数里，为什么在这个函数里？</h3><p>LateUpdate，是在所有的update结束后才调用，比较适合用于命令脚本的执行。官网上例子是摄像机的跟随，都是所有的update操作完才进行摄像机的跟进，不然就有可能出现摄像机已经推进了，但是视角里还未有角色的空帧出现。</p><h3 id="五十一：GPU的工作原理"><a href="#五十一：GPU的工作原理" class="headerlink" title="五十一：GPU的工作原理"></a>五十一：GPU的工作原理</h3><p>简而言之，GPU的图形（处理）流水线完成如下的工作：（并不一定是按照如下顺序） </p><ul><li>顶点处理：这阶段GPU读取描述3D图形外观的顶点数据并根据顶点数据确定3D图形的形状及位置关系，建立起3D图形的骨架。在支持DX8和DX9规格的GPU中，这些工作由硬件实现的Vertex Shader（定点着色器）完成。 </li><li>光栅化计算：显示器实际显示的图像是由像素组成的，我们需要将上面生成的图形上的点和线通过一定的算法转换到相应的像素点。把一个矢量图形转换为一系列像素点的过程就称为光栅化。例如，一条数学表示的斜线段，最终被转化成阶梯状的连续像素点。 </li><li>纹理帖图：顶点单元生成的多边形只构成了3D物体的轮廓，而纹理映射（texture mapping）工作完成对多变形表面的帖图，通俗的说，就是将多边形的表面贴上相应的图片，从而生成“真实”的图形。TMU（Texture mapping unit）即是用来完成此项工作。 </li><li>像素处理：这阶段（在对每个像素进行光栅化处理期间）GPU完成对像素的计算和处理，从而确定每个像素的最终属性。在支持DX8和DX9规格的GPU中，这些工作由硬件实现的Pixel Shader（像素着色器）完成。 </li><li>最终输出：由ROP（光栅化引擎）最终完成像素的输出，1帧渲染完毕后，被送到显存帧缓冲区。</li><li>总结：GPU的工作通俗的来说就是完成3D图形的生成，将图形映射到相应的像素点上，对每个像素进行计算确定最终颜色并完成输出。</li></ul><h3 id="五十二：什么是渲染管道？"><a href="#五十二：什么是渲染管道？" class="headerlink" title="五十二：什么是渲染管道？"></a>五十二：什么是渲染管道？</h3><p>是指在显示器上为了显示出图像而经过的一系列必要操作。 渲染管道中的很多步骤，都要将几何物体从一个坐标系中变换到另一个坐标系中去。主要步骤有：<br>本地坐标-&gt;视图坐标-&gt;背面裁剪-&gt;光照-&gt;裁剪-&gt;投影-&gt;视图变换-&gt;光栅化</p><h3 id="五十三：如何优化内存？"><a href="#五十三：如何优化内存？" class="headerlink" title="五十三：如何优化内存？"></a>五十三：如何优化内存？</h3><p>有很多种方式，例如</p><ul><li>1.压缩自带类库；</li><li>2.将暂时不用的以后还需要使用的物体隐藏起来而不是直接Destroy掉；</li><li>3.释放AssetBundle占用的资源；</li><li>4.降低模型的片面数，降低模型的骨骼数量，降低贴图的大小；</li><li>5.使用光照贴图，使用多层次细节(LOD)，使用着色器(Shader)，使用预设(Prefab)。</li><li>6.代码中少产生临时变量</li></ul><h3 id="五十四：动态加载资源的方式？他们之间的区别"><a href="#五十四：动态加载资源的方式？他们之间的区别" class="headerlink" title="五十四：动态加载资源的方式？他们之间的区别"></a>五十四：动态加载资源的方式？他们之间的区别</h3><ul><li>1.Resources.Load();</li><li>2.AssetBundle<br>区别参考</li></ul><h3 id="五十五：请描述游戏动画有哪几种，以及其原理？"><a href="#五十五：请描述游戏动画有哪几种，以及其原理？" class="headerlink" title="五十五：请描述游戏动画有哪几种，以及其原理？"></a>五十五：请描述游戏动画有哪几种，以及其原理？</h3><p>主要有关节动画、骨骼动画、单一网格模型动画(关键帧动画)。<br>关节动画：把角色分成若干独立部分，一个部分对应一个网格模型，部分的动画连接成一个整体的动画，角色比较灵活，Quake2中使用这种动画；<br>骨骼动画，广泛应用的动画方式，集成了以上两个方式的优点，骨骼按角色特点组成一定的层次结构，有关节相连，可做相对运动，皮肤作为单一网格蒙在骨骼之外，决定角色的外观；<br>单一网格模型动画由一个完整的网格模型构成，在动画序列的关键帧里记录各个顶点的原位置及其改变量，然后插值运算实现动画效果，角色动画较真实。</p><h3 id="五十六：alpha-blend工作原理"><a href="#五十六：alpha-blend工作原理" class="headerlink" title="五十六：alpha blend工作原理"></a>五十六：alpha blend工作原理</h3><p>Alpha Blend 实现透明效果，不过只能针对某块区域进行alpha操作，透明度可设。</p><h3 id="五十七：写出光照计算中的diffuse的计算公式"><a href="#五十七：写出光照计算中的diffuse的计算公式" class="headerlink" title="五十七：写出光照计算中的diffuse的计算公式"></a>五十七：写出光照计算中的diffuse的计算公式</h3><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">diffuse = Kd x colorLight x <span class="built_in">max</span>(<span class="built_in">N</span>*L,<span class="number">0</span>)；</span><br><span class="line">Kd 漫反射系数、colorLight 光的颜色、</span><br><span class="line"><span class="built_in">N</span> 单位法线向量、</span><br><span class="line">L 由点指向光源的单位向量、</span><br><span class="line">其中<span class="built_in">N</span>与L点乘，如果结果小于等于<span class="number">0</span>，则漫反射为<span class="number">0</span>。</span><br></pre></td></tr></table></figure><h3 id="五十八：两种阴影判断的方法、工作原理。"><a href="#五十八：两种阴影判断的方法、工作原理。" class="headerlink" title="五十八：两种阴影判断的方法、工作原理。"></a>五十八：两种阴影判断的方法、工作原理。</h3><ul><li>本影和半影：参考本影和半影</li><li>本影：景物表面上那些没有被光源直接照射的区域（全黑的轮廓分明的区域）。</li><li>半影：景物表面上那些被某些特定光源直接照射但并非被所有特定光源直接照射的区域（半明半暗区域）</li><li>工作原理：从光源处向物体的所有可见面投射光线，将这些面投影到场景中得到投影面，再将这些投影面与场景中的其他平面求交得出阴影多边形，保存这些阴影多边形信息，然后再按视点位置对场景进行相应处理得到所要求的视图（利用空间换时间，每次只需依据视点位置进行一次阴影计算即可，省去了一次消隐过程）</li></ul><h3 id="五十九：Vertex-Shader是什么，怎么计算？"><a href="#五十九：Vertex-Shader是什么，怎么计算？" class="headerlink" title="五十九：Vertex Shader是什么，怎么计算？"></a>五十九：Vertex Shader是什么，怎么计算？</h3><p>顶点着色器是一段执行在GPU上的程序，用来取代fixed pipeline中的transformation和lighting，Vertex Shader主要操作顶点。<br>Vertex Shader对输入顶点完成了从local space到homogeneous space（齐次空间）的变换过程，homogeneous space即projection space的下一个space。在这其间共有world transformation, view transformation和projection transformation及lighting几个过程。</p><h3 id="六十：下列代码在运行中会产生几个临时对象？"><a href="#六十：下列代码在运行中会产生几个临时对象？" class="headerlink" title="六十：下列代码在运行中会产生几个临时对象？"></a>六十：下列代码在运行中会产生几个临时对象？</h3><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> a = <span class="keyword">new</span> <span class="keyword">string</span>(<span class="string">"abc"</span>);</span><br><span class="line">a = (a.ToUpper() + <span class="string">"123"</span>).Substring(<span class="number">0</span>, <span class="number">2</span>); </span><br><span class="line">在C<span class="meta">#中第一行是会报错的（Java中倒是可行）。</span></span><br><span class="line">应该这样初始化：</span><br><span class="line"><span class="keyword">string</span> b = <span class="keyword">new</span> <span class="keyword">string</span>(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;);</span><br></pre></td></tr></table></figure><p>答案为：5个临时对象</p><h3 id="六十一：下列代码在运行中会发生什么问题？如何避免？"><a href="#六十一：下列代码在运行中会发生什么问题？如何避免？" class="headerlink" title="六十一：下列代码在运行中会发生什么问题？如何避免？"></a>六十一：下列代码在运行中会发生什么问题？如何避免？</h3><figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">List</span>&lt;<span class="keyword">int</span>&gt; ls = <span class="keyword">new</span> <span class="keyword">List</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">int</span> item in ls)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item * item);</span><br><span class="line">    ls.Remove(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>产生运行时错误，在 ls.Remove(item)这行，因为foreach是只读的。不能一边遍历一边修改。</p><h3 id="六十二：Unity3D是否支持写成多线程程序？如果支持的话需要注意什么？"><a href="#六十二：Unity3D是否支持写成多线程程序？如果支持的话需要注意什么？" class="headerlink" title="六十二：Unity3D是否支持写成多线程程序？如果支持的话需要注意什么？"></a>六十二：Unity3D是否支持写成多线程程序？如果支持的话需要注意什么？</h3><p>仅能从主线程中访问Unity3D的组件，对象和Unity3D系统调用<br>支持：如果同时你要处理很多事情或者与Unity的对象互动小可以用thread,否则使用coroutine。<br>注意：C#中有lock这个关键字,以确保只有一个线程可以在特定时间内访问特定的对象</p><h3 id="六十三：Unity3D的协程和C-线程之间的区别是什么？"><a href="#六十三：Unity3D的协程和C-线程之间的区别是什么？" class="headerlink" title="六十三：Unity3D的协程和C#线程之间的区别是什么？"></a>六十三：Unity3D的协程和C#线程之间的区别是什么？</h3><p>多线程程序同时运行多个线程 ，而在任一指定时刻只有一个协程在运行，并且这个正在运行的协同程序只在必要时才被挂起。除主线程之外的线程无法访问Unity3D的对象、组件、方法。<br>Unity3d没有多线程的概念，不过unity也给我们提供了StartCoroutine（协同程序）和LoadLevelAsync（异步加载关卡）后台加载场景的方法。 StartCoroutine为什么叫协同程序呢，所谓协同，就是当你在StartCoroutine的函数体里处理一段代码时，利用yield语句等待执行结果，这期间不影响主程序的继续执行，可以协同工作。</p><h3 id="六十四：矩阵相乘的意义及注意点"><a href="#六十四：矩阵相乘的意义及注意点" class="headerlink" title="六十四：矩阵相乘的意义及注意点"></a>六十四：矩阵相乘的意义及注意点</h3><p>用于表示线性变换：旋转、缩放、投影、平移、仿射<br>注意矩阵的蠕变：误差的积累</p><h3 id="六十五：为什么dynamic-font在unicode环境下优于static-font"><a href="#六十五：为什么dynamic-font在unicode环境下优于static-font" class="headerlink" title="六十五：为什么dynamic font在unicode环境下优于static font"></a>六十五：为什么dynamic font在unicode环境下优于static font</h3><p>Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。<br>使用动态字体时，Unity将不会预先生成一个与所有字体的字符纹理。当需要支持亚洲语言或者较大的字体的时候，若使用正常纹理，则字体的纹理将非常大。</p><h3 id="六十六：当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？"><a href="#六十六：当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？" class="headerlink" title="六十六：当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？"></a>六十六：当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？</h3><p>穿透（碰撞检测失败）</p><h3 id="六十七：请简述OnBecameVisible及OnBecameInvisible的发生时机，以及这一对回调函数的意义？"><a href="#六十七：请简述OnBecameVisible及OnBecameInvisible的发生时机，以及这一对回调函数的意义？" class="headerlink" title="六十七：请简述OnBecameVisible及OnBecameInvisible的发生时机，以及这一对回调函数的意义？"></a>六十七：请简述OnBecameVisible及OnBecameInvisible的发生时机，以及这一对回调函数的意义？</h3><p>当物体是否可见切换之时。可以用于只需要在物体可见时才进行的计算。</p><h3 id="六十八：什么叫动态合批？跟静态合批有什么区别？"><a href="#六十八：什么叫动态合批？跟静态合批有什么区别？" class="headerlink" title="六十八：什么叫动态合批？跟静态合批有什么区别？"></a>六十八：什么叫动态合批？跟静态合批有什么区别？</h3><p>如果动态物体共用着相同的材质，那么Unity会自动对这些物体进行批处理。动态批处理操作是自动完成的，并不需要你进行额外的操作。<br>区别：动态批处理一切都是自动的，不需要做任何操作，而且物体是可以移动的，但是限制很多。静态批处理：自由度很高，限制很少，缺点可能会占用更多的内存，而且经过静态批处理后的所有物体都不可以再移动了。<br>参考</p><h3 id="六十九：简述StringBuilder和String的区别？"><a href="#六十九：简述StringBuilder和String的区别？" class="headerlink" title="六十九：简述StringBuilder和String的区别？"></a>六十九：简述StringBuilder和String的区别？</h3><ul><li>String是字符串常量。</li><li>StringBuffer是字符串变量 ，线程安全。</li><li>StringBuilder是字符串变量，线程不安全。</li><li>String类型是个不可变的对象，当每次对String进行改变时都需要生成一个新的String对象，然后将指针指向一个新的对象，如果在一个循环里面，不断的改变一个对象，就要不断的生成新的对象，所以效率很低，建议在不断更改String对象的地方不要使用String类型。</li><li>StringBuilder对象在做字符串连接操作时是在原来的字符串上进行修改，改善了性能。这一点我们平时使用中也许都知道，连接操作频繁的时候，使用StringBuilder对象。</li></ul><h3 id="七十：Unity3D-Shader分哪几种，有什么区别？"><a href="#七十：Unity3D-Shader分哪几种，有什么区别？" class="headerlink" title="七十：Unity3D Shader分哪几种，有什么区别？"></a>七十：Unity3D Shader分哪几种，有什么区别？</h3><p>表面着色器的抽象层次比较高，它可以轻松地以简洁方式实现复杂着色。表面着色器可同时在前向渲染及延迟渲染模式下正常工作。<br>顶点片段着色器可以非常灵活地实现需要的效果，但是需要编写更多的代码，并且很难与Unity的渲染管线完美集成。<br>固定功能管线着色器可以作为前两种着色器的备用选择，当硬件无法运行那些酷炫Shader的时，还可以通过固定功能管线着色器来绘制出一些基本的内容。</p><h3 id="七十一：已知strcpy函数的原型是：char-strcpy-char-strDest-const-char-strSrc-1-不调用库函数，实现strcpy函数。2-解释为什么要返回char"><a href="#七十一：已知strcpy函数的原型是：char-strcpy-char-strDest-const-char-strSrc-1-不调用库函数，实现strcpy函数。2-解释为什么要返回char" class="headerlink" title="七十一：已知strcpy函数的原型是：char  strcpy(char  strDest,const char  strSrc); 1.不调用库函数，实现strcpy函数。2.解释为什么要返回char "></a>七十一：已知strcpy函数的原型是：char <em> strcpy(char </em> strDest,const char <em> strSrc); 1.不调用库函数，实现strcpy函数。2.解释为什么要返回char </em></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> * strDest,<span class="keyword">const</span> <span class="keyword">char</span> * strSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((strDest==<span class="literal">NULL</span>)||(strSrc==<span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"Invalid argument(s)"</span>;</span><br><span class="line">    <span class="keyword">char</span> * strDestCopy=strDest;</span><br><span class="line">    <span class="keyword">while</span> ((*strDest++=*strSrc++)!=<span class="string">'\0'</span>);</span><br><span class="line">    <span class="keyword">return</span> strDestCopy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七十二：C-中四种访问修饰符是哪些？各有什么区别？"><a href="#七十二：C-中四种访问修饰符是哪些？各有什么区别？" class="headerlink" title="七十二：C#中四种访问修饰符是哪些？各有什么区别？"></a>七十二：C#中四种访问修饰符是哪些？各有什么区别？</h3><p>1.属性修饰符 2.存取修饰符 3.类修饰符 4.成员修饰符。<br>属性修饰符：</p><ul><li>Serializable：按值将对象封送到远程服务器。</li><li>STATread：是单线程套间的意思，是一种线程模型。</li><li>MATAThread：是多线程套间的意思，也是一种线程模型。<br>存取修饰符：</li><li>public：存取不受限制。</li><li>private：只有包含该成员的类可以存取。</li><li>internal：只有当前工程可以存取。</li><li>protected：只有包含该成员的类以及派生类可以存取。<br>类修饰符：</li><li>abstract：抽象类。指示一个类只能作为其它类的基类。</li><li>sealed：密封类。指示一个类不能被继承。理所当然，密封类不能同时又是抽象类，因为抽象总是希望被继承的。<br>成员修饰符：</li><li>abstract：指示该方法或属性没有实现。</li><li>sealed：密封方法。可以防止在派生类中对该方法的override（重载）。不是类的每个成员方法都可以作为密封方法密封方法，必须对基类的虚方法进行重载，提供具体的实现方法。所以，在方法的声明中，sealed修饰符总是和override修饰符同时使用。</li><li>delegate：委托。用来定义一个函数指针。C#中的事件驱动是基于delegate + event的。</li><li>const：指定该成员的值只读不允许修改。</li><li>event：声明一个事件。</li><li>extern：指示方法在外部实现。</li><li>override：重写。对由基类继承成员的新实现。</li><li>readonly：指示一个域只能在声明时以及相同类的内部被赋值。</li><li>static：指示一个成员属于类型本身，而不是属于特定的对象。即在定义后可不经实例化，就可使用。</li><li>virtual：指示一个方法或存取器的实现可以在继承类中被覆盖。<br>new：在派生类中隐藏指定的基类成员，从而实现重写的功能。 若要隐藏继承类的成员，请使用相同名称在派生类中声明该成员，并用 new 修饰符修饰它。</li></ul><h3 id="七十三：Heap与Stack有何区别？"><a href="#七十三：Heap与Stack有何区别？" class="headerlink" title="七十三：Heap与Stack有何区别？"></a>七十三：Heap与Stack有何区别？</h3><ul><li>1.heap是堆，stack是栈。</li><li>2.stack的空间由操作系统自动分配和释放，heap的空间是手动申请和释放的，heap常用new关键字来分配。</li><li>3.stack空间有限，heap的空间是很大的自由区。</li></ul><h3 id="七十四：值类型和引用类型有何区别？"><a href="#七十四：值类型和引用类型有何区别？" class="headerlink" title="七十四：值类型和引用类型有何区别？"></a>七十四：值类型和引用类型有何区别？</h3><p>1.值类型的数据存储在内存的栈中；引用类型的数据存储在内存的堆中，而内存单元中只存放堆中对象的地址。<br>2.值类型存取速度快，引用类型存取速度慢。<br>3.值类型表示实际数据，引用类型表示指向存储在内存堆中的数据的指针或引用<br>4.值类型继承自System.ValueType，引用类型继承自System.Object<br>5.栈的内存分配是自动释放；而堆在.NET中会有GC来释放<br>6.值类型的变量直接存放实际的数据，而引用类型的变量存放的则是数据的地址，即对象的引用。</p><h3 id="七十五：协同程序的执行代码是什么？有何用处，有何缺点？"><a href="#七十五：协同程序的执行代码是什么？有何用处，有何缺点？" class="headerlink" title="七十五：协同程序的执行代码是什么？有何用处，有何缺点？"></a>七十五：协同程序的执行代码是什么？有何用处，有何缺点？</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Start</span><span class="params">()</span></span> &#123; </span><br><span class="line">    // 协同程序WaitAndPrint在Start函数内执行,可以视同于它与Start函数同步执行.</span><br><span class="line">    StartCoroutine(WaitAndPrint(<span class="number">2.0</span>)); </span><br><span class="line">    <span class="built_in">print</span> (<span class="string">"Before WaitAndPrint Finishes "</span> + Time.<span class="built_in">time</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WaitAndPrint</span> <span class="params">(waitTime : float)</span></span> &#123;</span><br><span class="line">    // 暂停执行waitTime秒</span><br><span class="line">    <span class="built_in">yield</span> WaitForSeconds (waitTime);</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">"WaitAndPrint "</span>+ Time.<span class="built_in">time</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用：一个协同程序在执行过程中,可以在任意位置使用yield语句。yield的返回值控制何时恢复协同程序向下执行。协同程序在对象自有帧执行过程中堪称优秀。协同程序在性能上没有更多的开销。<br>缺点：协同程序并非真线程，可能会发生堵塞。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算起来到现在为止面试的大多是游戏服务端或者web前端相关的类容，没有经历过一次正儿八经的Unity面试，通过面试题也可以侧面了解到Unity开发中有哪些常用的需要掌握的知识，因此搬运一篇号称“屎上最全”的博客当作备份。&lt;br&gt;
    
    </summary>
    
      <category term="game" scheme="https://blog.xiaomo.info/categories/game/"/>
    
    
      <category term="game" scheme="https://blog.xiaomo.info/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>经历了几场面试后的全球同服架构思考</title>
    <link href="https://blog.xiaomo.info/2019/worldServerGame/"/>
    <id>https://blog.xiaomo.info/2019/worldServerGame/</id>
    <published>2019-12-07T00:00:00.000Z</published>
    <updated>2020-06-28T16:53:07.143Z</updated>
    
    <content type="html"><![CDATA[<p>从自己的游戏从业经验来看，一直做的是滚服机制的游戏，当然也是因为我游戏从业经历不多。中国的网络游戏喜欢开小服，制造玩家矛盾，引起战斗，进而让用户心甘情愿充钱的氪金模式。日本的大部分游戏是做内容，所以基本上都是同服机制，但是因为知识水平受限面试表现并不尽如意，之后专门查资料研究了一番。<br><a id="more"></a><br>首先，游戏服务器是IO密集型服务器，它的主要瓶颈在网络IO，而不是CPU，这点要记住了。所以经常服务器问题都会出现在网络IO，带宽，数据库磁盘读写上面，而非CPU上面。</p><p>其实全球同服也就是大量在线，只是你看起来同服，而不是他本身就在同一个服务器上，或者同一个进程上，这是完全不现实的。一个好的服务器进程，能同时承载10k的游戏玩家(还依赖于游戏逻辑复杂度)已经不错了。其实要全球同服，就是堆服务器进程嘛。</p><ul><li>1.Gate: 首先要有一个(多个)Gate(网关)服务器，负责客户端连接及消息转发到GameServer(游戏服)（选服逻辑）,保持客户端到服务端的连接。没有任何逻辑，只做消息加密和解密，以及客户端和服务器消息的转发(相当于两者之间的桥梁).</li><li>2.GameServer: GameServer是主要的游戏进程,提供游戏逻辑功能(采用单进程(或者单线程)模型,游戏服务器的瓶颈从来不在CPU,所以只做逻辑功能的话单线程足够了,在这里没必要用多线程或多进程)。</li><li>3.DBManager: 实现数据库的读写，方便Game服务器异步读写数据库的数据(有些把数据库读写放在游戏服，没有单独的服务器，那恐怕游戏服单进程就不够用了)。</li><li>4.GameManager: 负责管理所有的GameServer，GameServer之间消息转发，提供广播到所有Game的功能。</li></ul><p>客户端连Gate，Gate连GameServer，GameServer连DBManager，GameManager管理所有的GameServer并通知所有的Gate。</p><p>除了GameManager只有一个，理论上Gate，GameServer，DBManager都可以扩展到多个实例，你要实现全球唯一服，理论上就是扩展GameServer，那么怎么让他们看起来在一个服呢？其实很简单，COC大多数都是单服玩法，只有交互玩法的时候你才能感受到它是同一个服。</p><p>主要讲讲GameServer，这是主要的处理服务器逻辑的地方，一般单进程就可以了，一个epoll_wait hold住全场，然后做分发，理论上cpu都能承载的住，而epoll能处理的上限，一般跟机器的内存有关，远大于1024，正常的也达到100k，当然考虑到逻辑的复杂度，一个实例一般处理的连接接近10k就可以了。<br>那怎么处理100k，1000k甚至更多了，那就多个实例，那这样还是唯一服吗？是的，至少可以看起来是，游戏自然有单人玩法和多人玩法，单人玩法自然自己在自己的服就可以了，谁也不知道是不是跟别人一个服。<br>当然有全服的排行榜，好友系统之类的怎么办呢，其实很简单，我们不是有GameManager吗，它就是负责做这事的，每当你发个好友请求，GameManager广播一条消息，然后如果有某个GameServer存在这个玩家，那就回应你，你们就可以相互通信了，更简单的想办法获取玩家的服务器ID号，直接通过GameManager转发给那个服务器，自然就可以通信了，就像在同一个服务器一样。<br>排行榜呢，最简单的，指定一个服务器，或者单独开辟一个服务器做排行榜，所有数据变动都通知这个服务器，然后服务器自然就能排行了，然后再广播。<br>双人战斗或者多人副本呢？<br>像COC这样的，掠夺战，我们当时的做法就是，直接搜到敌方，然后把自己的玩家，士兵军队等需要的数据序列化之后，传到对面的服务器去，反序列化，然后直接开打，打完再把数据传回来。<br>更多人的呢，那就方便点，再开辟一类服务器，叫BattleServer，专门负责多人玩法，副本玩法之类的，多人的时候，把所有的多人数据迁移到BattleServer，然后多人（副本玩法）结束的时候，再通过GameManager把数据迁移回原来的服务器。</p><p>这样看，其实全球唯一服也就没有那么高大上了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从自己的游戏从业经验来看，一直做的是滚服机制的游戏，当然也是因为我游戏从业经历不多。中国的网络游戏喜欢开小服，制造玩家矛盾，引起战斗，进而让用户心甘情愿充钱的氪金模式。日本的大部分游戏是做内容，所以基本上都是同服机制，但是因为知识水平受限面试表现并不尽如意，之后专门查资料研究了一番。&lt;br&gt;
    
    </summary>
    
      <category term="game" scheme="https://blog.xiaomo.info/categories/game/"/>
    
    
      <category term="game" scheme="https://blog.xiaomo.info/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>日语汉字速查表</title>
    <link href="https://blog.xiaomo.info/2019/japanKannjiIndex/"/>
    <id>https://blog.xiaomo.info/2019/japanKannjiIndex/</id>
    <published>2019-11-27T00:00:00.000Z</published>
    <updated>2020-06-28T16:53:07.143Z</updated>
    
    <content type="html"><![CDATA[<p>音读，训读，特殊读，平假名，片假名，王小明…..<br><a id="more"></a></p><ul><li>亜(あ)</li><li>哀(あい)</li><li>爱(あい)</li><li>悪(あく)</li><li>握(あく)</li><li>圧(あつ)</li><li>扱(あつかい)</li><li>安(あん)</li><li>暗(あん)</li><li>案(あん)</li><li>以(い)</li><li>位(くらい)</li><li>依(やすし)</li><li>伟(いさむ)</li><li>囲(かこい)</li><li>委(い)</li><li>威(い)</li><li>尉(い)</li><li>意(い)</li><li>慰(いさむ)</li><li>易(えき)</li><li>为(ため)</li><li>异(い)</li><li>移(うつり)</li><li>维(ゆい)</li><li>纬(い)</li><li>胃(い)</li><li>衣(ころも)</li><li>违(ちがい)</li><li>遗(い)</li><li>医(い)</li><li>井(せい)</li><li>域(いき)</li><li>育(いく)</li><li>一(いち)</li><li>壱(いち)</li><li>逸(すぐる)</li><li>稲(いね)</li><li>芋(いも)</li><li>印(いん)</li><li>员(いん)</li><li>因(いん)</li><li>姻(いん)</li><li>引(いん)</li><li>饮(いん)</li><li>院(いん)</li><li>阴(かげ)</li><li>隠(いん)</li><li>韵(いん)</li><li>右(みぎ)</li><li>宇(たか)</li><li>羽(はね)</li><li>雨(あめ)</li><li>涡(うず)</li><li>浦(うら)</li><li>运(うん)</li><li>云(くも)</li><li>営(えい)</li><li>影(かげ)</li><li>映(うつる)</li><li>栄(えい)</li><li>永(なが)</li><li>泳(およ)</li><li>英(えい)</li><li>卫(まもる)</li><li>咏(えい)</li><li>锐(はやし)</li><li>液(えき)</li><li>疫(えき)</li><li>益(えき)</li><li>駅(えき)</li><li>悦(えつ)</li><li>谒(えつ)</li><li>越(こし)</li><li>阅(えつ)</li><li>円(えん)</li><li>园(えん)</li><li>宴(えん)</li><li>延(えん)</li><li>援(えん)</li><li>沿(えん)</li><li>演(えん)</li><li>炎(ほのお)</li><li>烟(けむり)</li><li>猿(さる)</li><li>縁(えん)</li><li>远(えん)</li><li>铅(なまり)</li><li>塩(しお)</li><li>汚(きたな)</li><li>凹(ぼこ)</li><li>央(ひさし)</li><li>奥(おく)</li><li>往(おう)</li><li>応(おう)</li><li>押(おし)</li><li>横(よこ)</li><li>欧(おう)</li><li>殴(なぐ)</li><li>王(おう)</li><li>翁(おきな)</li><li>黄(き)</li><li>冲(おき)</li><li>亿(おく)</li><li>屋(や)</li><li>忆(おく)</li><li>乙(おつ)</li><li>卸(おろし)</li><li>恩(おん)</li><li>温(あつし)</li><li>穏(おん)</li><li>音(おん)</li><li>下(した)</li><li>化(か)</li><li>仮(かり)</li><li>何(なに)</li><li>価(あたい)</li><li>佳(よろし)</li><li>加(か)</li><li>可(か)</li><li>夏(なつ)</li><li>嫁(よめ)</li><li>家(いえ)</li><li>寡(やもめ)</li><li>科(か)</li><li>暇(ひま)</li><li>果(はたし)</li><li>架(か)</li><li>歌(うた)</li><li>河(かわ)</li><li>火(ひ)</li><li>祸(わざわい)</li><li>稼(かせぎ)</li><li>个(か)</li><li>花(はな)</li><li>荷(に)</li><li>华(はな)</li><li>菓(か)</li><li>课(か)</li><li>货(か)</li><li>过(か)</li><li>蚊(か)</li><li>我(われ)</li><li>画(が)</li><li>芽(め)</li><li>贺(が)</li><li>雅(が)</li><li>饿(が)</li><li>介(すけ)</li><li>会(かい)</li><li>解(かい)</li><li>回(かい)</li><li>块(かたまり)</li><li>壊(こわ)</li><li>快(かい)</li><li>怪(かい)</li><li>悔(くや)</li><li>懐(ふところ)</li><li>戒(かい)</li><li>拐(かい)</li><li>改(あらた)</li><li>械(かい)</li><li>海(うみ)</li><li>灰(はい)</li><li>界(かい)</li><li>皆(みな)</li><li>絵(え)</li><li>开(かい)</li><li>阶(かい)</li><li>贝(かい)</li><li>劾(がい)</li><li>外(がい)</li><li>害(がい)</li><li>慨(がい)</li><li>概(おおむね)</li><li>涯(がい)</li><li>街(まち)</li><li>该(がい)</li><li>垣(かき)</li><li>吓(かく)</li><li>各(かく)</li><li>拡(ひろむ)</li><li>格(かく)</li><li>核(かく)</li><li>壳(から)</li><li>获(え)</li><li>确(あきら)</li><li>获(ゆたか)</li><li>覚(さとる)</li><li>角(かど)</li><li>较(くら)</li><li>郭(くるわ)</li><li>阁(かく)</li><li>隔(へだ)</li><li>革(かわ)</li><li>学(がく)</li><li>岳(たけ)</li><li>楽(らく)</li><li>额(がく)</li><li>挂(かかり)</li><li>潟(かた)</li><li>割(わり)</li><li>喝(かつ)</li><li>括(くく)</li><li>活(かつ)</li><li>渇(かつ)</li><li>滑(なめら)</li><li>褐(かつ)</li><li>辖(かつ)</li><li>且(かつ)</li><li>株(かぶ)</li><li>刈(かり)</li><li>乾(いぬい)</li><li>冠(かん)</li><li>寒(かん)</li><li>刊(かん)</li><li>勘(かん)</li><li>勧(すすむ)</li><li>巻(かん)</li><li>唤(かん)</li><li>堪(かん)</li><li>完(かん)</li><li>官(かん)</li><li>寛(ひろし)</li><li>干(かん)</li><li>干(みき)</li><li>患(わずら)</li><li>感(かん)</li><li>惯(な)</li><li>憾(かん)</li><li>换(かん)</li><li>敢(かん)</li><li>棺(ひつぎ)</li><li>款(かん)</li><li>歓(かん)</li><li>汗(あせ)</li><li>汉(かん)</li><li>环(わ)</li><li>甘(かん)</li><li>监(らん)</li><li>看(み)</li><li>管(かん)</li><li>简(かん)</li><li>缓(ゆる)</li><li>缶(かん)</li><li>肝(きも)</li><li>舰(かん)</li><li>観(かん)</li><li>贯(ぬき)</li><li>还(かん)</li><li>鉴(かがみ)</li><li>间(あいだ)</li><li>闲(ひま)</li><li>関(せき)</li><li>陥(おちい)</li><li>馆(かん)</li><li>丸(まる)</li><li>含(ふくみ)</li><li>岸(きし)</li><li>眼(め)</li><li>岩(いわ)</li><li>顽(がん)</li><li>颜(かお)</li><li>愿(ねがい)</li><li>企(くわだ)</li><li>危(あぶ)</li><li>喜(よし)</li><li>器(うつわ)</li><li>基(もと)</li><li>奇(き)</li><li>寄(やどりき)</li><li>岐(ちまた)</li><li>希(まれ)</li><li>几(いく)</li><li>忌(いみ)</li><li>挥(き)</li><li>机(つくえ)</li><li>旗(はた)</li><li>既(き)</li><li>期(き)</li><li>棋(ぎ)</li><li>弃(す)</li><li>机(き)</li><li>帰(き)</li><li>気(き)</li><li>汽(き)</li><li>祈(いのり)</li><li>季(き)</li><li>纪(おさむ)</li><li>规(き)</li><li>记(き)</li><li>贵(き)</li><li>起(おこし)</li><li>轨(き)</li><li>辉(てる)</li><li>饥(う)</li><li>骑(き)</li><li>鬼(おに)</li><li>伪(ぎ)</li><li>仪(ぎ)</li><li>宜(ぎ)</li><li>戯(ぎ)</li><li>技(わざ)</li><li>拟(ぎ)</li><li>欺(ぎ)</li><li>犠(ぎ)</li><li>疑(うたが)</li><li>义(ぎ)</li><li>议(ぎ)</li><li>菊(きく)</li><li>吉(きち)</li><li>吃(いさむ)</li><li>诘(つめ)</li><li>却(きゃく)</li><li>客(きゃく)</li><li>脚(あし)</li><li>虐(ぎゃく)</li><li>逆(ぎゃく)</li><li>丘(おか)</li><li>久(ひさし)</li><li>休(きゅう)</li><li>及(およぶ)</li><li>吸(きゅう)</li><li>宫(みや)</li><li>弓(ゆみ)</li><li>急(きゅう)</li><li>救(すくい)</li><li>朽(きゅう)</li><li>求(もとむ)</li><li>泣(な)</li><li>球(たま)</li><li>究(きわむ)</li><li>穷(きゅう)</li><li>级(きゅう)</li><li>纠(ただす)</li><li>给(きゅう)</li><li>旧(きゅう)</li><li>牛(うし)</li><li>去(きょ)</li><li>居(きょ)</li><li>巨(きょ)</li><li>拒(こば)</li><li>拠(きょ)</li><li>挙(きょ)</li><li>虚(きょ)</li><li>许(もと)</li><li>距(きょ)</li><li>渔(りょう)</li><li>鱼(さかな)</li><li>享(すすむ)</li><li>京(きょう)</li><li>供(とも)</li><li>竞(せり)</li><li>共(とも)</li><li>凶(きょう)</li><li>协(きょう)</li><li>叫(きょう)</li><li>境(さかい)</li><li>峡(きょう)</li><li>强(つよし)</li><li>恐(おそ)</li><li>恭(やすし)</li><li>挟(はさ)</li><li>教(きょう)</li><li>桥(はし)</li><li>况(きょう)</li><li>狂(きょう)</li><li>狭(せま)</li><li>矫(きょう)</li><li>胸(むね)</li><li>胁(おびや)</li><li>兴(きょう)</li><li>郷(ごう)</li><li>镜(かがみ)</li><li>响(ひびき)</li><li>惊(おどろき)</li><li>仰(あおぎ)</li><li>凝(ぎょう)</li><li>暁(あかつき)</li><li>业(ぎょう)</li><li>局(きょく)</li><li>曲(きょく)</li><li>极(きょく)</li><li>玉(たま)</li><li>勤(つとむ)</li><li>均(たもつ)</li><li>斤(きん)</li><li>琴(こと)</li><li>禁(きん)</li><li>筋(すじ)</li><li>紧(みしと)</li><li>菌(きん)</li><li>襟(えり)</li><li>谨(すすむ)</li><li>近(こん)</li><li>金(きん)</li><li>吟(ぎん)</li><li>银(ぎん)</li><li>九(きゅう)</li><li>句(く)</li><li>区(く)</li><li>苦(く)</li><li>駆(く)</li><li>具(ぐ)</li><li>愚(ぐ)</li><li>虞(おそれ)</li><li>空(そら)</li><li>偶(ぐう)</li><li>遇(ぐう)</li><li>隅(すみ)</li><li>屈(くつ)</li><li>掘(ほり)</li><li>靴(くつ)</li><li>缲(くり)</li><li>桑(くわ)</li><li>勲(いさお)</li><li>君(きみ)</li><li>薫(かおる)</li><li>训(くん)</li><li>群(ぐん)</li><li>军(ぐん)</li><li>郡(ぐん)</li><li>系(かかり)</li><li>倾(なだれ)</li><li>刑(けい)</li><li>兄(あに)</li><li>启(けい)</li><li>型(かた)</li><li>契(ちぎり)</li><li>形(けい)</li><li>径(けい)</li><li>恵(めぐみ)</li><li>庆(けい)</li><li>憩(いこい)</li><li>掲(けい)</li><li>携(たずさ)</li><li>敬(けい)</li><li>景(かげ)</li><li>渓(けい)</li><li>系(けい)</li><li>経(きょう)</li><li>継(つぎ)</li><li>茎(くき)</li><li>蛍(ほたる)</li><li>计(けい)</li><li>警(けい)</li><li>軽(けい)</li><li>鶏(にわとり)</li><li>芸(げい)</li><li>迎(むかい)</li><li>鲸(くじら)</li><li>剧(げき)</li><li>撃(げき)</li><li>激(げき)</li><li>杰(すぐる)</li><li>欠(けつ)</li><li>决(けつ)</li><li>洁(きよし)</li><li>穴(あな)</li><li>结(むすぶ)</li><li>血(ち)</li><li>月(つき)</li><li>件(けん)</li><li>倹(けん)</li><li>健(けん)</li><li>兼(けん)</li><li>券(けん)</li><li>剣(けん)</li><li>圏(けん)</li><li>坚(けん)</li><li>嫌(いや)</li><li>建(けん)</li><li>宪(けん)</li><li>悬(かけ)</li><li>検(けん)</li><li>権(けん)</li><li>犬(いぬ)</li><li>献(けん)</li><li>研(けん)</li><li>绢(きぬ)</li><li>県(けん)</li><li>肩(かた)</li><li>见(み)</li><li>谦(けん)</li><li>贤(けん)</li><li>轩(のき)</li><li>遣(つか)</li><li>険(けん)</li><li>顕(けん)</li><li>験(しるし)</li><li>元(もと)</li><li>原(はら)</li><li>厳(げん)</li><li>幻(まぼろし)</li><li>弦(つる)</li><li>减(げん)</li><li>源(みなもと)</li><li>玄(げん)</li><li>现(うつつ)</li><li>言(げん)</li><li>限(きり)</li><li>个(こ)</li><li>古(いにしえ)</li><li>呼(こ)</li><li>固(かたむ)</li><li>孤(こ)</li><li>己(おのれ)</li><li>库(こ)</li><li>弧(こ)</li><li>戸(と)</li><li>故(ゆえ)</li><li>枯(かれ)</li><li>湖(みずうみ)</li><li>夸(ほこ)</li><li>雇(やとい)</li><li>顾(かえりみ)</li><li>鼓(つづみ)</li><li>五(ご)</li><li>互(たがい)</li><li>午(うま)</li><li>呉(くれ)</li><li>娯(ご)</li><li>后(ご)</li><li>御(お)</li><li>悟(さとる)</li><li>碁(ご)</li><li>语(ご)</li><li>误(ご)</li><li>护(ゆずる)</li><li>交(こう)</li><li>侯(こう)</li><li>候(こう)</li><li>光(ひかり)</li><li>公(こう)</li><li>功(こう)</li><li>効(こう)</li><li>厚(あつし)</li><li>口(くち)</li><li>向(むかい)</li><li>后(きさき)</li><li>坑(こう)</li><li>好(よしみ)</li><li>孔(あな)</li><li>孝(たかし)</li><li>工(こう)</li><li>巧(こう)</li><li>幸(さいわい)</li><li>広(ひろ)</li><li>康(やすし)</li><li>恒(つね)</li><li>慌(あわ)</li><li>抗(こう)</li><li>拘(かか)</li><li>控(ひかえ)</li><li>攻(こう)</li><li>更(さら)</li><li>校(こう)</li><li>构(かまえ)</li><li>江(え)</li><li>洪(こう)</li><li>港(みなと)</li><li>沟(みぞ)</li><li>甲(こう)</li><li>皇(すべらぎ)</li><li>硬(こう)</li><li>稿(こう)</li><li>红(べに)</li><li>绞(しぼり)</li><li>纲(つな)</li><li>耕(こう)</li><li>考(こう)</li><li>肯(こう)</li><li>航(こう)</li><li>荒(あら)</li><li>行(ぎょう)</li><li>衡(たいら)</li><li>讲(こう)</li><li>贡(みつぐ)</li><li>购(こう)</li><li>郊(こう)</li><li>酵(こう)</li><li>鉱(こう)</li><li>钢(こう)</li><li>降(たかし)</li><li>项(こう)</li><li>香(かおり)</li><li>高(たか)</li><li>刚(ごう)</li><li>号(ごう)</li><li>合(ごう)</li><li>拷(ごう)</li><li>豪(ごう)</li><li>克(かつみ)</li><li>刻(こく)</li><li>告(こく)</li><li>国(こく)</li><li>谷(こく)</li><li>酷(こく)</li><li>黒(くろ)</li><li>狱(ごく)</li><li>腰(こし)</li><li>骨(ほね)</li><li>込(こみ)</li><li>今(いま)</li><li>困(こま)</li><li>垦(ひらく)</li><li>婚(こん)</li><li>恨(うら)</li><li>恳(こん)</li><li>昆(こん)</li><li>根(ね)</li><li>混(こん)</li><li>绀(こん)</li><li>魂(たましい)</li><li>佐(さ)</li><li>唆(さ)</li><li>左(ひだり)</li><li>差(さ)</li><li>査(さ)</li><li>砂(すな)</li><li>诈(さ)</li><li>锁(くさり)</li><li>座(ざ)</li><li>债(さい)</li><li>催(もよお)</li><li>再(さい)</li><li>最(さい)</li><li>妻(つま)</li><li>宰(つかさ)</li><li>彩(いろどり)</li><li>才(さい)</li><li>采(さい)</li><li>栽(さい)</li><li>歳(とし)</li><li>済(すみ)</li><li>灾(わざわ)</li><li>砕(くだ)</li><li>祭(さい)</li><li>斎(いわい)</li><li>细(ほそ)</li><li>菜(な)</li><li>裁(さい)</li><li>载(みつる)</li><li>际(さい)</li><li>剤(ざい)</li><li>在(ざい)</li><li>材(ざい)</li><li>罪(つみ)</li><li>财(ざい)</li><li>坂(さか)</li><li>咲(さき)</li><li>崎(ざき)</li><li>作(さく)</li><li>削(けず)</li><li>榨(しぼ)</li><li>昨(さく)</li><li>策(さく)</li><li>索(さく)</li><li>错(さく)</li><li>桜(さくら)</li><li>册(さつ)</li><li>刷(さつ)</li><li>察(さつ)</li><li>撮(さつ)</li><li>擦(さつ)</li><li>札(さつ)</li><li>杀(ころ)</li><li>雑(ざつ)</li><li>皿(さら)</li><li>三(さん)</li><li>伞(かさ)</li><li>参(さん)</li><li>山(やま)</li><li>惨(さん)</li><li>散(さん)</li><li>桟(さん)</li><li>产(さん)</li><li>算(ざん)</li><li>蚕(かいこ)</li><li>賛(さん)</li><li>酸(さん)</li><li>暂(ざん)</li><li>残(ざん)</li><li>仕(つこう)</li><li>伺(うかがい)</li><li>使(つか)</li><li>刺(とげ)</li><li>司(つかさ)</li><li>史(し)</li><li>嗣(つぐ)</li><li>四(よん)</li><li>士(し)</li><li>始(はじめ)</li><li>姉(あね)</li><li>姿(すがた)</li><li>子(こ)</li><li>市(し)</li><li>师(し)</li><li>志(こころざし)</li><li>思(おもう)</li><li>指(ゆび)</li><li>支(ささ)</li><li>施(し)</li><li>旨(むね)</li><li>枝(えだ)</li><li>止(どめ)</li><li>死(し)</li><li>氏(し)</li><li>祉(し)</li><li>私(わたし)</li><li>糸(いと)</li><li>纸(かみ)</li><li>紫(むらさき)</li><li>肢(あし)</li><li>脂(あぶら)</li><li>至(いたる)</li><li>视(し)</li><li>词(し)</li><li>诗(し)</li><li>试(ためし)</li><li>志(し)</li><li>谘(とう)</li><li>资(し)</li><li>赐(たまもの)</li><li>雌(めす)</li><li>饲(か)</li><li>歯(は)</li><li>事(こと)</li><li>似(に)</li><li>侍(さむらい)</li><li>児(じ)</li><li>字(じ)</li><li>寺(てら)</li><li>慈(めぐむ)</li><li>持(もち)</li><li>时(とき)</li><li>次(つぎ)</li><li>滋(しげる)</li><li>治(おさむ)</li><li>玺(じ)</li><li>磁(じ)</li><li>示(しめす)</li><li>耳(みみ)</li><li>自(じ)</li><li>辞(じ)</li><li>式(しき)</li><li>识(さとし)</li><li>轴(じく)</li><li>七(しち)</li><li>执(もり)</li><li>失(しつ)</li><li>室(しつ)</li><li>湿(しつ)</li><li>漆(うるし)</li><li>疾(しつ)</li><li>质(しつ)</li><li>実(じつ)</li><li>芝(しば)</li><li>舎(しゃ)</li><li>写(しゃ)</li><li>射(い)</li><li>舍(しゃ)</li><li>赦(しゃ)</li><li>斜(しゃ)</li><li>煮(に)</li><li>社(しゃ)</li><li>者(しゃ)</li><li>谢(しゃ)</li><li>车(くるま)</li><li>遮(さえぎ)</li><li>蛇(へび)</li><li>邪(よこしま)</li><li>借(しゃく)</li><li>勺(しゃく)</li><li>尺(しゃく)</li><li>爵(たか)</li><li>酌(しゃく)</li><li>釈(せき)</li><li>若(わか)</li><li>寂(じゃく)</li><li>弱(じゃく)</li><li>主(しゅ)</li><li>取(とり)</li><li>守(かみ)</li><li>手(て)</li><li>朱(しゅ)</li><li>殊(こと)</li><li>狩(かり)</li><li>珠(たま)</li><li>种(たね)</li><li>趣(おもむき)</li><li>酒(さけ)</li><li>首(くび)</li><li>儒(じゅ)</li><li>受(うけ)</li><li>寿(ことぶき)</li><li>授(じゅ)</li><li>树(き)</li><li>需(もとめ)</li><li>囚(しゅう)</li><li>収(おさむ)</li><li>周(しゅう)</li><li>宗(しゅう)</li><li>就(しゅう)</li><li>州(しゅう)</li><li>修(おさむ)</li><li>愁(しゅう)</li><li>拾(おさむ)</li><li>秀(ひで)</li><li>秋(あき)</li><li>终(しゅう)</li><li>习(ならい)</li><li>臭(しゅう)</li><li>舟(ふね)</li><li>众(しゅう)</li><li>袭(おそい)</li><li>周(しゅう)</li><li>酬(しゅう)</li><li>集(しゅう)</li><li>丑(しゅう)</li><li>住(じゅう)</li><li>充(みつる)</li><li>十(じゅう)</li><li>従(じゅう)</li><li>柔(じゅう)</li><li>汁(しる)</li><li>渋(しぶ)</li><li>獣(けもの)</li><li>縦(たて)</li><li>重(しげる)</li><li>铳(じゅう)</li><li>叔(すえ)</li><li>宿(やど)</li><li>淑(よし)</li><li>祝(しゅく)</li><li>缩(ちぢみ)</li><li>粛(しゅく)</li><li>塾(じゅく)</li><li>熟(じゅく)</li><li>出(で)</li><li>术(じゅつ)</li><li>述(のべる)</li><li>俊(しゅん)</li><li>春(はる)</li><li>瞬(しゅん)</li><li>准(じゅん)</li><li>循(めぐる)</li><li>旬(しゅん)</li><li>殉(じゅん)</li><li>准(じゅん)</li><li>润(じゅん)</li><li>盾(たて)</li><li>纯(じゅん)</li><li>巡(じゅん)</li><li>遵(じゅん)</li><li>顺(じゅん)</li><li>処(ところ)</li><li>初(しょ)</li><li>所(しょ)</li><li>暑(しょ)</li><li>庶(ちかし)</li><li>绪(ちょ)</li><li>署(しょ)</li><li>书(しょ)</li><li>诸(もろ)</li><li>助(すけ)</li><li>叙(じょ)</li><li>女(おんな)</li><li>序(じょ)</li><li>徐(じょ)</li><li>除(じょ)</li><li>伤(きず)</li><li>偿(しょう)</li><li>胜(かつ)</li><li>匠(たくみ)</li><li>升(ます)</li><li>召(しょう)</li><li>商(しょう)</li><li>唱(うた)</li><li>奨(すすむ)</li><li>宵(よい)</li><li>将(しょう)</li><li>小(しょう)</li><li>少(しょう)</li><li>尚(なお)</li><li>床(ゆか)</li><li>彰(あきら)</li><li>承(うけたまわ)</li><li>抄(しょう)</li><li>招(しょう)</li><li>掌(てのひら)</li><li>升(のぼる)</li><li>昭(あきら)</li><li>晶(あきら)</li><li>松(まつ)</li><li>沼(ぬま)</li><li>消(け)</li><li>渉(わたる)</li><li>焼(やき)</li><li>焦(あせ)</li><li>照(てる)</li><li>症(しょう)</li><li>省(しょう)</li><li>硝(しょう)</li><li>礁(しょう)</li><li>祥(しょ)</li><li>称(しょう)</li><li>章(しょう)</li><li>笑(わらい)</li><li>妆(しょう)</li><li>绍(たすく)</li><li>肖(あやか)</li><li>冲(しょう)</li><li>讼(しょう)</li><li>证(あかし)</li><li>诏(みことのり)</li><li>详(しょう)</li><li>象(ぞう)</li><li>赏(しょう)</li><li>钟(かね)</li><li>障(さわ)</li><li>上(じょう)</li><li>丈(たけ)</li><li>乗(じょう)</li><li>冗(じょう)</li><li>剰(じょう)</li><li>城(しろ)</li><li>场(ば)</li><li>壌(ゆずる)</li><li>嬢(じょう)</li><li>常(つね)</li><li>情(じょう)</li><li>条(じょう)</li><li>浄(じょう)</li><li>状(じょう)</li><li>畳(たたみ)</li><li>蒸(むし)</li><li>譲(ゆずる)</li><li>醸(じょう)</li><li>锭(じょう)</li><li>嘱(しょく)</li><li>饰(かざり)</li><li>植(うえ)</li><li>殖(しょく)</li><li>织(おり)</li><li>职(しょく)</li><li>色(いろ)</li><li>触(しょく)</li><li>食(しょく)</li><li>辱(はじ)</li><li>伸(しん)</li><li>信(しん)</li><li>侵(おか)</li><li>唇(くちびる)</li><li>娠(しん)</li><li>寝(ね)</li><li>审(しん)</li><li>心(こころ)</li><li>慎(まき)</li><li>振(おさむ)</li><li>新(しん)</li><li>森(もり)</li><li>浸(ひた)</li><li>深(しん)</li><li>申(さる)</li><li>真(まこと)</li><li>神(かみ)</li><li>绅(しん)</li><li>臣(しん)</li><li>薪(たきぎ)</li><li>亲(おや)</li><li>诊(み)</li><li>身(み)</li><li>辛(しん)</li><li>进(すすむ)</li><li>针(はり)</li><li>震(しん)</li><li>人(じん)</li><li>仁(じん)</li><li>刃(は)</li><li>寻(ひろ)</li><li>甚(じん)</li><li>尽(じん)</li><li>迅(じん)</li><li>阵(じん)</li><li>酢(す)</li><li>図(ず)</li><li>吹(すい)</li><li>垂(たれ)</li><li>帅(そち)</li><li>推(すい)</li><li>水(みず)</li><li>炊(すい)</li><li>睡(すい)</li><li>粋(いき)</li><li>衰(おとろ)</li><li>遂(やすし)</li><li>酔(すい)</li><li>锤(おもり)</li><li>随(ずい)</li><li>髄(ずい)</li><li>崇(たかし)</li><li>数(かず)</li><li>枢(かなめ)</li><li>据(きょ)</li><li>杉(すぎ)</li><li>澄(きよむ)</li><li>寸(すん)</li><li>世(よ)</li><li>瀬(せ)</li><li>亩(うね)</li><li>是(これ)</li><li>制(せい)</li><li>势(ぜい)</li><li>姓(せい)</li><li>征(ただし)</li><li>性(せい)</li><li>成(しげる)</li><li>政(せい)</li><li>整(ただし)</li><li>星(ほし)</li><li>晴(はれ)</li><li>正(せい)</li><li>清(せい)</li><li>牲(せい)</li><li>生(しょう)</li><li>盛(もり)</li><li>精(せい)</li><li>圣(ひじり)</li><li>声(こえ)</li><li>制(せい)</li><li>西(にし)</li><li>诚(まこと)</li><li>誓(ちかい)</li><li>请(しょう)</li><li>逝(ゆ)</li><li>青(あお)</li><li>静(せい)</li><li>斉(さい)</li><li>税(ぜい)</li><li>只(せき)</li><li>席(せき)</li><li>惜(せき)</li><li>斥(せき)</li><li>昔(むかし)</li><li>析(せき)</li><li>石(いし)</li><li>积(せき)</li><li>籍(せき)</li><li>绩(つむぎ)</li><li>责(せき)</li><li>赤(あか)</li><li>迹(あと)</li><li>切(きり)</li><li>拙(せつ)</li><li>接(せつ)</li><li>摂(せつ)</li><li>折(おり)</li><li>设(せつ)</li><li>窃(せつ)</li><li>节(せつ)</li><li>说(せつ)</li><li>雪(ゆき)</li><li>绝(ぜつ)</li><li>舌(した)</li><li>仙(せん)</li><li>先(さき)</li><li>千(せん)</li><li>占(うらない)</li><li>宣(よろし)</li><li>専(あつむ)</li><li>川(かわ)</li><li>戦(いくさ)</li><li>扇(おうぎ)</li><li>栓(せん)</li><li>泉(いずみ)</li><li>浅(あさ)</li><li>洗(すすぐ)</li><li>染(そめ)</li><li>潜(ひそか)</li><li>旋(めぐる)</li><li>线(せん)</li><li>繊(せん)</li><li>船(せん)</li><li>荐(すすむ)</li><li>践(せん)</li><li>选(せん)</li><li>迁(せん)</li><li>銭(ぜに)</li><li>铣(せん)</li><li>鲜(あらた)</li><li>前(まえ)</li><li>善(ぜん)</li><li>渐(すすむ)</li><li>然(ぜん)</li><li>全(ぜん)</li><li>禅(ぜん)</li><li>缮(つくろ)</li><li>塑(そ)</li><li>措(そ)</li><li>疎(そ)</li><li>础(いしずえ)</li><li>祖(そ)</li><li>租(そ)</li><li>粗(ほぼ)</li><li>素(す)</li><li>组(くみ)</li><li>诉(うった)</li><li>阻(はば)</li><li>僧(そう)</li><li>创(きず)</li><li>双(そう)</li><li>仓(くら)</li><li>丧(も)</li><li>壮(そう)</li><li>奏(そう)</li><li>层(そう)</li><li>想(そう)</li><li>捜(さが)</li><li>扫(は)</li><li>挿(ざし)</li><li>操(みさお)</li><li>早(はや)</li><li>曹(そう)</li><li>巣(す)</li><li>槽(そう)</li><li>燥(そう)</li><li>争(あらそ)</li><li>相(そう)</li><li>窓(まど)</li><li>総(ふさ)</li><li>草(くさ)</li><li>荘(しょう)</li><li>葬(そう)</li><li>藻(も)</li><li>装(そう)</li><li>走(そう)</li><li>送(そう)</li><li>遭(あ)</li><li>霜(しも)</li><li>騒(さわ)</li><li>像(ぞう)</li><li>増(ぞう)</li><li>憎(ぞう)</li><li>臓(ぞう)</li><li>蔵(くら)</li><li>赠(おく)</li><li>造(づくり)</li><li>促(うなが)</li><li>侧(がわ)</li><li>则(のり)</li><li>即(そく)</li><li>息(いき)</li><li>束(たば)</li><li>测(はかり)</li><li>足(あし)</li><li>速(はやし)</li><li>俗(ぞく)</li><li>属(ぞく)</li><li>贼(ぞく)</li><li>族(ぞく)</li><li>続(ぞく)</li><li>卒(そつ)</li><li>存(ぞん)</li><li>孙(まご)</li><li>尊(みこと)</li><li>损(そん)</li><li>村(むら)</li><li>他(ほか)</li><li>多(た)</li><li>太(ふとし)</li><li>堕(だ)</li><li>妥(ゆずる)</li><li>惰(だ)</li><li>打(だ)</li><li>駄(だ)</li><li>体(からだ)</li><li>対(たい)</li><li>耐(しのぶ)</li><li>帯(おび)</li><li>待(まつ)</li><li>怠(おこた)</li><li>态(たい)</li><li>替(たい)</li><li>泰(はた)</li><li>滞(たい)</li><li>胎(はら)</li><li>袋(ふくろ)</li><li>贷(かし)</li><li>退(たい)</li><li>逮(たい)</li><li>队(たい)</li><li>代(だい)</li><li>台(だい)</li><li>大(だい)</li><li>第(だい)</li><li>题(だい)</li><li>滝(たき)</li><li>卓(たく)</li><li>宅(たく)</li><li>択(たく)</li><li>拓(つぶせ)</li><li>沢(さわ)</li><li>濯(たく)</li><li>托(ことづけ)</li><li>浊(だく)</li><li>诺(だく)</li><li>但(ただし)</li><li>达(たち)</li><li>夺(だっ)</li><li>脱(だつ)</li><li>棚(だな)</li><li>谷(たに)</li><li>丹(に)</li><li>単(たん)</li><li>叹(たん)</li><li>担(たん)</li><li>探(さぐ)</li><li>淡(たん)</li><li>炭(すみ)</li><li>短(たん)</li><li>端(はし)</li><li>胆(きも)</li><li>诞(たん)</li><li>锻(きたえ)</li><li>団(だん)</li><li>坛(だん)</li><li>弾(たま)</li><li>断(だん)</li><li>暖(だん)</li><li>段(だん)</li><li>男(おとこ)</li><li>谈(だん)</li><li>値(あたい)</li><li>知(ち)</li><li>地(ち)</li><li>耻(はじ)</li><li>池(いけ)</li><li>痴(ち)</li><li>稚(おさない)</li><li>置(おき)</li><li>致(いたす)</li><li>遅(ち)</li><li>筑(ちく)</li><li>畜(ちく)</li><li>竹(たけ)</li><li>蓄(ちく)</li><li>逐(ちく)</li><li>秩(さとし)</li><li>窒(ちつ)</li><li>茶(ちゃ)</li><li>嫡(ちゃく)</li><li>着(き)</li><li>中(なか)</li><li>仲(なか)</li><li>宙(ちゅう)</li><li>忠(ちゅう)</li><li>抽(ちゅう)</li><li>昼(ひる)</li><li>柱(はしら)</li><li>注(ちゅう)</li><li>虫(むし)</li><li>衷(まこと)</li><li>鋳(い)</li><li>驻(ちゅう)</li><li>著(ちょ)</li><li>贮(ちょ)</li><li>丁(ちょう)</li><li>兆(ちょう)</li><li>帐(とばり)</li><li>庁(ちょう)</li><li>吊(とむら)</li><li>张(はり)</li><li>雕(ほり)</li><li>徴(しるし)</li><li>惩(ちょう)</li><li>挑(いど)</li><li>朝(あさ)</li><li>潮(しお)</li><li>町(まち)</li><li>眺(なが)</li><li>聴(ちょう)</li><li>胀(ちょう)</li><li>肠(ちょう)</li><li>调(ちょう)</li><li>超(ちょう)</li><li>跳(は)</li><li>长(ちょう)</li><li>顶(いただき)</li><li>鸟(とり)</li><li>勅(ちょく)</li><li>直(ちょく)</li><li>朕(ちん)</li><li>沈(ちん)</li><li>珍(ちん)</li><li>赁(ちん)</li><li>镇(しん)</li><li>陈(ちん)</li><li>津(つ)</li><li>坠(つい)</li><li>追(つい)</li><li>痛(つう)</li><li>通(つう)</li><li>冢(つか)</li><li>渍(づけ)</li><li>坪(つぼ)</li><li>钓(つり)</li><li>亭(てい)</li><li>低(てい)</li><li>停(てい)</li><li>侦(てい)</li><li>贞(さだ)</li><li>呈(てい)</li><li>堤(つつみ)</li><li>定(さだむ)</li><li>帝(てい)</li><li>底(そこ)</li><li>庭(にわ)</li><li>廷(てい)</li><li>弟(おとうと)</li><li>抵(てい)</li><li>提(つつみ)</li><li>程(ほど)</li><li>缔(しめ)</li><li>艇(てい)</li><li>订(てい)</li><li>逓(てい)</li><li>邸(やしき)</li><li>泥(どろ)</li><li>摘(てき)</li><li>敌(てき)</li><li>滴(しずく)</li><li>的(まと)</li><li>笛(ふえ)</li><li>适(てき)</li><li>哲(てつ)</li><li>彻(とおる)</li><li>撤(てつ)</li><li>迭(てつ)</li><li>鉄(てつ)</li><li>典(てん)</li><li>天(てん)</li><li>展(てん)</li><li>店(てん)</li><li>添(そう)</li><li>転(てん)</li><li>点(てん)</li><li>伝(でん)</li><li>殿(どの)</li><li>田(た)</li><li>电(でん)</li><li>吐(は)</li><li>涂(ぬり)</li><li>徒(と)</li><li>斗(はかる)</li><li>渡(わたり)</li><li>登(のぼる)</li><li>途(と)</li><li>都(みやこ)</li><li>努(つとむ)</li><li>度(ど)</li><li>土(つち)</li><li>奴(やつ)</li><li>怒(いかり)</li><li>倒(だおれ)</li><li>党(とう)</li><li>冬(ふゆ)</li><li>冻(こお)</li><li>刀(かたな)</li><li>唐(とう)</li><li>塔(とう)</li><li>岛(しま)</li><li>悼(いたむ)</li><li>投(とう)</li><li>搭(とう)</li><li>东(ひがし)</li><li>桃(もも)</li><li>栋(むね)</li><li>盗(ぬす)</li><li>汤(ゆ)</li><li>灯(ひ)</li><li>当(とう)</li><li>痘(とう)</li><li>等(とう)</li><li>答(こたえ)</li><li>筒(つつ)</li><li>糖(とう)</li><li>统(おさむ)</li><li>到(いたる)</li><li>讨(う)</li><li>誊(とう)</li><li>豆(まめ)</li><li>踏(とう)</li><li>逃(のが)</li><li>透(とおる)</li><li>陶(すえ)</li><li>头(あたま)</li><li>腾(とう)</li><li>闘(たたか)</li><li>働(はたらき)</li><li>动(どう)</li><li>同(どう)</li><li>堂(どう)</li><li>导(しるべ)</li><li>洞(ほら)</li><li>童(わらべ)</li><li>胴(どう)</li><li>道(みち)</li><li>铜(どう)</li><li>峠(とうげ)</li><li>匿(とく)</li><li>得(とく)</li><li>徳(とく)</li><li>特(とく)</li><li>督(よし)</li><li>笃(あつし)</li><li>毒(どく)</li><li>独(どく)</li><li>読(どく)</li><li>凸(でこ)</li><li>突(とつ)</li><li>届(とどけ)</li><li>屯(たむろ)</li><li>豚(ぶた)</li><li>昙(くもり)</li><li>钝(どん)</li><li>内(ない)</li><li>縄(なわ)</li><li>南(みなみ)</li><li>软(やわ)</li><li>难(なん)</li><li>二(に)</li><li>尼(あま)</li><li>弐(に)</li><li>肉(にく)</li><li>日(ひ)</li><li>乳(ちち)</li><li>入(いり)</li><li>如(ぎん)</li><li>尿(にょう)</li><li>任(にん)</li><li>妊(にん)</li><li>忍(にん)</li><li>认(しのぶ)</li><li>宁(やすし)</li><li>猫(ねこ)</li><li>热(ねつ)</li><li>年(とし)</li><li>念(ねん)</li><li>燃(ねん)</li><li>粘(ねん)</li><li>悩(なや)</li><li>浓(のう)</li><li>纳(おさむ)</li><li>能(のう)</li><li>脳(のう)</li><li>农(のう)</li><li>把(たば)</li><li>覇(は)</li><li>波(なみ)</li><li>派(は)</li><li>破(やぶ)</li><li>婆(ばばあ)</li><li>马(うま)</li><li>俳(はい)</li><li>廃(はい)</li><li>拝(おが)</li><li>排(はい)</li><li>败(はい)</li><li>杯(さかずき)</li><li>背(せ)</li><li>肺(はい)</li><li>辈(やから)</li><li>配(くば)</li><li>倍(ばい)</li><li>培(つちかう)</li><li>媒(ばい)</li><li>梅(うめ)</li><li>买(ばい)</li><li>売(ばい)</li><li>赔(ばい)</li><li>陪(ばい)</li><li>伯(はく)</li><li>博(ひろし)</li><li>拍(はく)</li><li>泊(はく)</li><li>白(しろ)</li><li>舶(はく)</li><li>薄(すすき)</li><li>迫(はさま)</li><li>漠(ばく)</li><li>爆(ばく)</li><li>缚(ばく)</li><li>麦(むぎ)</li><li>箱(はこ)</li><li>肌(はだ)</li><li>畑(はたけ)</li><li>八(はち)</li><li>钵(はち)</li><li>発(はつ)</li><li>髪(かみ)</li><li>伐(ばつ)</li><li>罚(ばち)</li><li>抜(ぬ)</li><li>阀(ばつ)</li><li>伴(とも)</li><li>判(はん)</li><li>半(はん)</li><li>反(はん)</li><li>帆(ほ)</li><li>搬(はん)</li><li>板(いた)</li><li>版(はん)</li><li>犯(はん)</li><li>班(はん)</li><li>畔(あぜ)</li><li>繁(しげる)</li><li>般(ぱん)</li><li>藩(はん)</li><li>贩(はん)</li><li>范(はん)</li><li>烦(はん)</li><li>颁(はん)</li><li>饭(めし)</li><li>晩(ばん)</li><li>番(ばん)</li><li>盘(ばん)</li><li>蛮(ばん)</li><li>卑(いや)</li><li>否(いな)</li><li>妃(きさき)</li><li>彼(かれ)</li><li>悲(かな)</li><li>扉(とびら)</li><li>批(ひ)</li><li>披(ひ)</li><li>比(ひ)</li><li>泌(ひつ)</li><li>疲(つか)</li><li>皮(かわ)</li><li>碑(ひ)</li><li>秘(ひ)</li><li>罢(ひ)</li><li>肥(こえ)</li><li>被(ひ)</li><li>费(ひ)</li><li>避(さ)</li><li>非(ひ)</li><li>飞(とび)</li><li>备(そなえ)</li><li>尾(お)</li><li>微(び)</li><li>美(び)</li><li>鼻(はな)</li><li>匹(ぴき)</li><li>必(ひつ)</li><li>笔(ふで)</li><li>姫(ひめ)</li><li>百(ひゃく)</li><li>表(たわら)</li><li>标(ひょう)</li><li>氷(こおり)</li><li>漂(ただよ)</li><li>票(ひょう)</li><li>表(おもて)</li><li>评(ひょう)</li><li>描(びょう)</li><li>病(びょう)</li><li>秒(びょう)</li><li>苗(なえ)</li><li>品(ひん)</li><li>浜(はま)</li><li>贫(ひん)</li><li>宾(ひん)</li><li>频(ひん)</li><li>敏(びん)</li><li>瓶(びん)</li><li>不(ふ)</li><li>付(づけ)</li><li>夫(おっと)</li><li>妇(ふ)</li><li>富(とみ)</li><li>布(ぬの)</li><li>府(ふ)</li><li>怖(こわ)</li><li>扶(たもつ)</li><li>敷(しき)</li><li>普(すすむ)</li><li>浮(うき)</li><li>父(ちち)</li><li>符(ふ)</li><li>腐(くさ)</li><li>肤(はだ)</li><li>谱(ふ)</li><li>负(ふ)</li><li>赋(みつぐ)</li><li>赴(おもむ)</li><li>附(ふ)</li><li>侮(ぶ)</li><li>武(ぶ)</li><li>舞(まい)</li><li>部(ぶ)</li><li>封(ふう)</li><li>风(ふう)</li><li>伏(ふし)</li><li>副(ふく)</li><li>复(また)</li><li>幅(はば)</li><li>服(ふく)</li><li>福(ふく)</li><li>腹(はら)</li><li>复(ふく)</li><li>覆(くつがえ)</li><li>払(ばらい)</li><li>沸(ふつ)</li><li>仏(ふつ)</li><li>物(ぶつ)</li><li>分(ぶん)</li><li>喷(ふん)</li><li>坟(ふん)</li><li>愤(いきどお)</li><li>奋(いさむ)</li><li>粉(こな)</li><li>纷(まぎ)</li><li>雰(ふん)</li><li>文(ぶん)</li><li>闻(ぶん)</li><li>丙(へい)</li><li>并(へい)</li><li>兵(へい)</li><li>塀(へい)</li><li>币(へい)</li><li>平(ひら)</li><li>弊(へい)</li><li>柄(え)</li><li>并(なみ)</li><li>闭(へい)</li><li>陛(のぼる)</li><li>米(べい)</li><li>壁(かべ)</li><li>癖(くせ)</li><li>别(べつ)</li><li>偏(へん)</li><li>変(へん)</li><li>片(かた)</li><li>编(へん)</li><li>辺(へん)</li><li>返(へん)</li><li>遍(へん)</li><li>便(びん)</li><li>勉(つとむ)</li><li>弁(べん)</li><li>保(ほ)</li><li>舗(ほ)</li><li>捕(つか)</li><li>歩(ほ)</li><li>补(たすく)</li><li>穂(ほ)</li><li>募(つのる)</li><li>墓(はか)</li><li>慕(した)</li><li>暮(くれ)</li><li>母(はは)</li><li>簿(ぼ)</li><li>仿(ほう)</li><li>俸(ほう)</li><li>包(つつみ)</li><li>报(ほう)</li><li>奉(みつぐ)</li><li>宝(たから)</li><li>峰(みね)</li><li>崩(くずれ)</li><li>抱(かかえ)</li><li>放(ほう)</li><li>方(かた)</li><li>法(ほう)</li><li>泡(あわ)</li><li>炮(ほう)</li><li>缝(ぬい)</li><li>胞(ほう)</li><li>芳(よし)</li><li>褒(ほ)</li><li>访(おとず)</li><li>豊(とよ)</li><li>邦(ほう)</li><li>饱(あ)</li><li>乏(ぼう)</li><li>亡(ぼう)</li><li>傍(そば)</li><li>剖(ぼう)</li><li>坊(ぼう)</li><li>妨(さまた)</li><li>帽(ぼう)</li><li>忘(わす)</li><li>忙(いそが)</li><li>房(ふさ)</li><li>暴(あば)</li><li>望(ぼう)</li><li>某(ぼう)</li><li>棒(ぼう)</li><li>冒(ぼう)</li><li>纺(ぼう)</li><li>肪(ぼう)</li><li>膨(ふく)</li><li>谋(はかりごと)</li><li>贸(ぼう)</li><li>防(ぼう)</li><li>北(きた)</li><li>仆(ぼく)</li><li>墨(すみ)</li><li>扑(ぼく)</li><li>朴(ぼく)</li><li>牧(まき)</li><li>没(ぼつ)</li><li>堀(ほり)</li><li>奔(ほん)</li><li>本(ほん)</li><li>翻(ほん)</li><li>凡(ぼん)</li><li>盆(ぼん)</li><li>摩(ま)</li><li>磨(おさむ)</li><li>魔(ま)</li><li>麻(あさ)</li><li>埋(まい)</li><li>妹(いもうと)</li><li>枚(まい)</li><li>毎(ごと)</li><li>幕(まく)</li><li>膜(まく)</li><li>又(また)</li><li>抹(まつ)</li><li>末(すえ)</li><li>茧(まゆ)</li><li>万(よろず)</li><li>慢(まん)</li><li>満(まん)</li><li>漫(まん)</li><li>味(あじ)</li><li>未(み)</li><li>魅(み)</li><li>岬(みさき)</li><li>密(みつ)</li><li>脉(みゃく)</li><li>妙(みょう)</li><li>民(みん)</li><li>眠(みん)</li><li>务(つとむ)</li><li>梦(ゆめ)</li><li>无(む)</li><li>矛(ほこ)</li><li>雾(きり)</li><li>婿(むこ)</li><li>娘(むすめ)</li><li>名(めい)</li><li>命(いのち)</li><li>明(めい)</li><li>盟(めい)</li><li>迷(めい)</li><li>铭(めい)</li><li>鸣(なる)</li><li>灭(めつ)</li><li>免(めん)</li><li>绵(わた)</li><li>面(めん)</li><li>模(ぼ)</li><li>茂(しげる)</li><li>妄(もう)</li><li>毛(け)</li><li>猛(たける)</li><li>盲(もう)</li><li>网(もう)</li><li>耗(もう)</li><li>木(き)</li><li>黙(もく)</li><li>目(め)</li><li>戻(もどり)</li><li>问(とい)</li><li>纹(もん)</li><li>门(もん)</li><li>匁(もんめ)</li><li>夜(よる)</li><li>野(の)</li><li>矢(や)</li><li>厄(やく)</li><li>役(えき)</li><li>约(やく)</li><li>薬(くすり)</li><li>訳(やく)</li><li>跃(おど)</li><li>柳(やなぎ)</li><li>愉(さとる)</li><li>油(あぶら)</li><li>愈(ゆ)</li><li>谕(さとし)</li><li>输(ゆ)</li><li>唯(ただ)</li><li>优(ゆう)</li><li>勇(ゆう)</li><li>友(とも)</li><li>幽(ゆう)</li><li>悠(ゆう)</li><li>忧(うれ)</li><li>有(ゆう)</li><li>犹(なお)</li><li>由(よし)</li><li>裕(ゆう)</li><li>诱(ゆう)</li><li>游(ゆう)</li><li>邮(ゆう)</li><li>雄(おす)</li><li>融(ゆう)</li><li>夕(ゆう)</li><li>予(よ)</li><li>余(よ)</li><li>与(あたえ)</li><li>誉(ほまれ)</li><li>预(あずかり)</li><li>幼(よう)</li><li>容(かたち)</li><li>庸(よう)</li><li>扬(よう)</li><li>揺(ゆ)</li><li>拥(まもる)</li><li>曜(ひかり)</li><li>様(さま)</li><li>洋(よう)</li><li>溶(よう)</li><li>用(よう)</li><li>窑(かま)</li><li>羊(ひつじ)</li><li>叶(は)</li><li>要(よう)</li><li>谣(うたい)</li><li>踊(おどり)</li><li>阳(よう)</li><li>养(おさむ)</li><li>抑(おおき)</li><li>欲(よく)</li><li>浴(よく)</li><li>翌(よく)</li><li>翼(つばさ)</li><li>罗(ら)</li><li>裸(はだか)</li><li>来(らい)</li><li>頼(より)</li><li>雷(かみなり)</li><li>络(らく)</li><li>落(おち)</li><li>酪(らく)</li><li>乱(らん)</li><li>卵(たまご)</li><li>栏(らん)</li><li>滥(らん)</li><li>覧(らん)</li><li>利(り)</li><li>吏(つかさ)</li><li>履(くつ)</li><li>理(り)</li><li>痢(り)</li><li>裏(うら)</li><li>里(さと)</li><li>离(はなれ)</li><li>陆(りく)</li><li>律(りつ)</li><li>率(りつ)</li><li>立(りつ)</li><li>略(りゃく)</li><li>流(りゅう)</li><li>留(どめ)</li><li>硫(りゅう)</li><li>粒(つぶ)</li><li>隆(たかし)</li><li>竜(りゅう)</li><li>虑(りょ)</li><li>旅(たび)</li><li>虏(とりこ)</li><li>了(りょう)</li><li>僚(しかさ)</li><li>両(りょう)</li><li>寮(りょう)</li><li>料(りょう)</li><li>凉(りょう)</li><li>猟(りょう)</li><li>疗(りょう)</li><li>粮(かて)</li><li>良(りょう)</li><li>量(りょう)</li><li>陵(みささぎ)</li><li>领(りょう)</li><li>力(ちから)</li><li>绿(みどり)</li><li>伦(たぐい)</li><li>厘(りん)</li><li>林(はやし)</li><li>临(のぞむ)</li><li>轮(わ)</li><li>隣(となり)</li><li>塁(るい)</li><li>涙(なみだ)</li><li>累(るい)</li><li>类(たぐい)</li><li>令(れい)</li><li>例(れい)</li><li>冷(ひや)</li><li>励(つとむ)</li><li>礼(れい)</li><li>铃(すず)</li><li>隷(れい)</li><li>零(ぜろ)</li><li>霊(れい)</li><li>丽(うるわ)</li><li>齢(よわい)</li><li>暦(こよみ)</li><li>歴(れき)</li><li>列(れつ)</li><li>劣(れつ)</li><li>烈(れつ)</li><li>裂(れつ)</li><li>廉(かど)</li><li>恋(こい)</li><li>练(ねり)</li><li>连(れん)</li><li>錬(きたう)</li><li>炉(ろ)</li><li>路(ろ)</li><li>露(つゆ)</li><li>労(ろう)</li><li>廊(ろう)</li><li>朗(あきら)</li><li>楼(ろう)</li><li>浪(なみ)</li><li>漏(ろう)</li><li>老(ろう)</li><li>郎(ろう)</li><li>六(ろく)</li><li>录(ろく)</li><li>论(ろん)</li><li>和(わ)</li><li>话(はなし)</li><li>贿(まかない)</li><li>惑(まど)</li><li>枠(わく)</li><li>湾(わん)</li><li>腕(うで)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;音读，训读，特殊读，平假名，片假名，王小明…..&lt;br&gt;
    
    </summary>
    
      <category term="japan" scheme="https://blog.xiaomo.info/categories/japan/"/>
    
    
      <category term="生活" scheme="https://blog.xiaomo.info/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>签证总结大全（工作签、在留卡加汉字、工作签证更新、家族签证等）</title>
    <link href="https://blog.xiaomo.info/2019/aboutAllVisa/"/>
    <id>https://blog.xiaomo.info/2019/aboutAllVisa/</id>
    <published>2019-10-21T00:00:00.000Z</published>
    <updated>2020-06-28T16:53:07.143Z</updated>
    
    <content type="html"><![CDATA[<p>今天办理了家族签证和工作签更新，突然发现自己接触的签证相关的也有4种类型了，所以差不多可以做个总结性blog了。今天办签证遇到的坑很多，感觉真是难以言说。先是公司资料没有寄到，自己去公司拿了一趟。之后告知需要去区役所开非课税证明，而去了之后说是未满一年开不了。各种种的坑，觉得需要记录下来，给需要的朋友少走弯路。<br><a id="more"></a></p><h1 id="东京入管局概述"><a href="#东京入管局概述" class="headerlink" title="东京入管局概述"></a>东京入管局概述</h1><p>东京入管局一共有5个区，分别是A（红色）留学类、更新再交付 B（橘黄色）签证更新、C（蓝色）就劳相谈、D（绿色）永驻/再交付/再入国、E（1楼）家族签证。ABCD在二楼，E在1楼。</p><h1 id="首次工作签"><a href="#首次工作签" class="headerlink" title="首次工作签"></a>首次工作签</h1><p>理论上来说大专以上的学历都是可以到日本工作的，只要在日本的公司给offer就可以。所以首先是在招聘App上更新简历，我是通过猎聘app上拿到的offer。日本IT相关工作非常缺人，一般来说单纯在上面更新一下简历不需要投递就会有一大波猎头主动过去找你。然后就是精挑细选，挑出觉得比较合适的公司和猎头沟通进行面试安排。一般来说首次来日工作的话都是进的华人外派公司作为跳板，待1-2年之后有合适的机会再换。所以远程面试可能会用wechat视频等不是很正规的方式。等offer确定后就可以和公司沟通办理签证相关事项了，工作签证需要3个月左右。给大家一个提醒，还没给你发工资就要找你要钱的果断拉黑，都9102了相信也不会有人会被这种骗术骗到了吧。</p><h2 id="需要的资料"><a href="#需要的资料" class="headerlink" title="需要的资料"></a>需要的资料</h2><ol><li>毕业证</li><li>学位证（专科不需要）</li><li>护照</li></ol><p>将1-3资料国际快递给公司，之后剩下的时间就是等待了。如果这期间日语不是很好，而经济又不是很紧张的话可以报个班学习一下，这点投入是很值得的。</p><h2 id="去日本需要准备的东西"><a href="#去日本需要准备的东西" class="headerlink" title="去日本需要准备的东西"></a>去日本需要准备的东西</h2><p>这些内容一般来说公司会交代，但是不一定会很详细，在此列举一下。</p><ol><li>印章（12mm左右），日本社会对印章信任度大过签字</li><li>一张visa或jcb的信用卡，银联不可。因为不支持绑定手机卡消费</li><li>西瓜卡（可以在淘宝上买，也可以下飞机了再买，不过提前准备我觉得更好，坐车吃饭都可以用）</li><li>现金若干，不用太多，刷卡一样的，主要用来应急用。</li><li>手机卡（或者在支付宝买一个国际流量包）</li><li>家族关系公正书（公正处可以办），主要用来年底申请抚养时退税用，如果不在乎这点钱就直接忽略吧</li><li>一些小东西，比如指甲钳、挖耳勺之类的刚到日本可能都不知道在哪买，自备一个挺方便。（推荐一个日本的百元连锁店Daiso，生活用品又全又便宜）</li></ol><p>以上是1年前来日本时准备的东西的回忆版，可能有所遗漏，想到再补充吧。</p><h1 id="在留卡加汉字"><a href="#在留卡加汉字" class="headerlink" title="在留卡加汉字"></a>在留卡加汉字</h1><p>初次工作签到日本的话，拿着在留资格认定书在入关换在留卡的时候给的卡是只有拼音名字。如果觉得不方便的话可以之后去入管局申请加一下汉字，当天就能拿到。</p><h2 id="需要的资料-1"><a href="#需要的资料-1" class="headerlink" title="需要的资料"></a>需要的资料</h2><ol><li>护照</li><li>在留卡</li><li>申请表（可以到入管了再拿申请表填）</li><li>照片*1</li><li>1500日币</li></ol><p>去拿新的在留卡的时候他们会把你原来的在留卡挖个洞再还给你。老的在留卡虽然不知道还有没有用，但是最好不要丢，拿回去放着，也不会吃你家大米不是？</p><h1 id="工作签到期更新"><a href="#工作签到期更新" class="headerlink" title="工作签到期更新"></a>工作签到期更新</h1><p>在签证快到期时就在留意去入管更新了，一般在到期前3个月都可以去。要跑两趟的，第一趟去申请更新，会拿到回执。之后会寄通知单过来，再去一趟拿新的在留卡，需要4000日币的更新费用。拿到新的在留卡之后记得把填的老的在留卡的信息的地方全部更新一下，然后拍一张电子照留存。</p><p>办理更新是在B区，也是人最多的一个区，拿号都得排队。B1-B4是资料提交区，B5-B6是回执交付区。也就是说在B1-B4递送资料，然后在B5-B6等着。B7是排队拿号的地方，也是噩梦的开始。在等候区有个日本老头找我们聊天说以后如果来入管尽量避开周一和周四，说这2天人超级多。感觉日本的老头老太太都好優しい啊，来日本没多久已经被很多老头老太太关照，暖心的不得了。</p><p>这是从公司拿到的资料<br><img src="/img/blog/visa_update_from_company.jpg" width="30%" height="30%"></p><p>2019年11月25追记：<br>时隔整整一个月，入管终于把通知去拿在留卡的明信片送过来了，然后带上必要的资料去换卡就好了。我早上7点左右出发，11点拿到在留卡（2楼A1区），天还下着雨。但是拿到3年的签证还是很开心的，同事更新后还是一年，虽然不知道有什么讲究。</p><ul><li>护照</li><li>在留卡</li><li>回执</li><li>通知卡</li><li>4000円（到入管后的全家便利店买4000的邮票）</li></ul><h2 id="需要的资料-2"><a href="#需要的资料-2" class="headerlink" title="需要的资料"></a>需要的资料</h2><ol><li>在留期间申请更新表</li><li>照片 4*3 白底 无帽 正面（3个月内，如果不在3个月内也不要用和上一个在留卡一样的照片，这不是明明白白的告诉他们你的照片是1年前的么）</li><li>在留卡</li><li>护照</li><li>住民税证明（不满1年不需要，因为也开不出来。日本不会出现踢皮球式的刁难，一边不给开另一边非得要） </li></ol><h1 id="以下资料公司准备"><a href="#以下资料公司准备" class="headerlink" title="以下资料公司准备"></a>以下资料公司准备</h1><ol start="6"><li>雇用契约书 （公司准备）</li><li>登记薄滕本（公司准备）</li><li>决算报告书（公司准备）</li><li>法定调书合计表（公司准备）</li><li>在留期间更新许可申请书（公司准备）</li></ol><p>这个是拿到的回执单，一把辛酸泪。<br><img src="/img/blog/visa_update_result.jpg" width="30%" height="30%"></p><h1 id="家族签证"><a href="#家族签证" class="headerlink" title="家族签证"></a>家族签证</h1><p>这次的家族签证是给老婆孩子办的，家族签证可以在日本生活但没有就劳资格。申请所需要时间在1-3个月之间。据说提交的资料越全下签越快，通过率越高，所以我也是尽可能的多准备些资料。换到在留卡之后可以去区役所申请补助，一个月1万5000日元，一直补贴到16岁。1岁半之后就可以免费送去保育园上学，3岁后可以免费上幼儿园。如果抚养者交了社保或者国民健康保险的话老婆孩子都可以享受福利。一家3口，孩子全免，大人负担30%，一个月上限8万日元。以下是所需的资料：</p><h2 id="申请书"><a href="#申请书" class="headerlink" title="申请书"></a>申请书</h2><ol><li>家族签证申请书（有几个人就需要填几份）</li></ol><h2 id="复印件"><a href="#复印件" class="headerlink" title="复印件"></a>复印件</h2><ol><li>护照复印件</li><li>在留卡复印件</li><li>结婚证复印件</li><li>出生证明复印件（没有孩子就不需要）</li></ol><h2 id="公正书"><a href="#公正书" class="headerlink" title="公正书"></a>公正书</h2><ol><li>家族关系公正书</li><li>结婚证公正书</li><li>出生证明公正书（没有孩子就不需要）</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>夫妻交往照片*10</li><li>证件照*1（小孩的也需要，我在官网查的资料写16岁以下不要，去了又说要可急坏了我，最后拍了一张护照上的照片应急搞定了） </li><li>在职证明</li><li>未来半年的收入证明</li><li>去1楼的全家花417买简易书留的信封</li></ol><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li>剪刀（打照片剪照片用）</li><li>固体胶（贴照片用）</li><li>笔和本子</li><li>订书机（固定资料）</li><li>在留卡（申请者身份证明）</li><li>护照（提前都复印好了可以不用带）</li></ol><p>这是个自己做的一些记录<br><img src="/img/blog/visa_update.jpg" width="30%" height="30%"></p><p>这个是家族签证的回执单<br><img src="/img/blog/family_result.jpg" width="30%" height="30%"></p><h1 id="高级人才签证"><a href="#高级人才签证" class="headerlink" title="高级人才签证"></a>高级人才签证</h1><p>目前暂未涉及，留坑以后补充</p><h1 id="永住者签证"><a href="#永住者签证" class="headerlink" title="永住者签证"></a>永住者签证</h1><p>目前暂未涉及，留坑以后补充</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天办理了家族签证和工作签更新，突然发现自己接触的签证相关的也有4种类型了，所以差不多可以做个总结性blog了。今天办签证遇到的坑很多，感觉真是难以言说。先是公司资料没有寄到，自己去公司拿了一趟。之后告知需要去区役所开非课税证明，而去了之后说是未满一年开不了。各种种的坑，觉得需要记录下来，给需要的朋友少走弯路。&lt;br&gt;
    
    </summary>
    
      <category term="japan" scheme="https://blog.xiaomo.info/categories/japan/"/>
    
    
      <category term="生活" scheme="https://blog.xiaomo.info/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>jdk源码系列-Java到底是值传递还是引用传递？</title>
    <link href="https://blog.xiaomo.info/2019/javaPassByValueAndReference/"/>
    <id>https://blog.xiaomo.info/2019/javaPassByValueAndReference/</id>
    <published>2019-08-05T00:00:00.000Z</published>
    <updated>2020-06-28T16:53:07.143Z</updated>
    
    <content type="html"><![CDATA[<p>首先，不要纠结于 Pass By Value 和 Pass By Reference 的字面上的意义，否则很容易陷入所谓的“一切传引用其实本质上是传值”这种并不能解决问题无意义论战中。更何况，要想知道Java到底是传值还是传引用，起码你要先知道传值和传引用的准确含义吧？可是如果你已经知道了这两个名字的准确含义，那么你自己就能判断Java到底是传值还是传引用。这就好像用大学的名词来解释高中的题目，对于初学者根本没有任何意义。<br><a id="more"></a></p><h1 id="一、搞清楚-基本类型-和-引用类型的不同之处"><a href="#一、搞清楚-基本类型-和-引用类型的不同之处" class="headerlink" title="一、搞清楚 基本类型 和 引用类型的不同之处"></a>一、搞清楚 基本类型 和 引用类型的不同之处</h1><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">int num</span> = 10;</span><br><span class="line"><span class="attribute">String str</span> = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><p><img src="https://pic3.zhimg.com/80/166032bc90958c21604110441ad03f45_hd.jpg" alt></p><p>如图所示，num是基本类型，值就直接保存在变量中。而str是引用类型，变量中保存的只是实际对象的地址。一般称这种变量为”引用”，引用指向实际对象，实际对象中保存着内容。</p><h1 id="二、搞清楚赋值运算符（-）的作用"><a href="#二、搞清楚赋值运算符（-）的作用" class="headerlink" title="二、搞清楚赋值运算符（=）的作用"></a>二、搞清楚赋值运算符（=）的作用</h1><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">int num</span> = 10;</span><br><span class="line"><span class="attribute">String str</span> = <span class="string">"hello"</span>;</span><br><span class="line"><span class="attribute">num</span> = 20;</span><br><span class="line"><span class="attribute">str</span> = <span class="string">"java"</span>;</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/287c0efbb179638cf4cf27cbfdf3e746_hd.jpg" alt></p><p>对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。<code>但是原来的对象不会被改变（重要）。</code> 如上图所示，”hello” 字符串对象没有被改变。（没有被任何引用所指向的对象是垃圾，会被垃圾回收器回收）</p><h1 id="三、调用方法时发生了什么？参数传递基本上就是赋值操作。"><a href="#三、调用方法时发生了什么？参数传递基本上就是赋值操作。" class="headerlink" title="三、调用方法时发生了什么？参数传递基本上就是赋值操作。"></a>三、调用方法时发生了什么？参数传递基本上就是赋值操作。</h1><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">第一个例子：基本类型</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">value</span> = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(num); <span class="comment">// num 没有被改变</span></span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">第二个例子：没有提供改变自身方法的引用类型</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">String</span> <span class="built_in">text</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">text</span> = <span class="string">"windows"</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(str); <span class="comment">// str 也没有被改变</span></span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">第三个例子：提供了改变自身方法的引用类型</span><br><span class="line"><span class="keyword">StringBuilder </span><span class="built_in">sb</span> = new <span class="keyword">StringBuilder("iphone");</span></span><br><span class="line"><span class="keyword">void </span>foo(<span class="keyword">StringBuilder </span><span class="keyword">builder) </span>&#123;</span><br><span class="line">    <span class="keyword">builder.append("4");</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br><span class="line"><span class="keyword">foo(sb); </span>// <span class="built_in">sb</span> 被改变了，变成了<span class="string">"iphone4"</span>。</span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。</span><br><span class="line"><span class="keyword">StringBuilder </span><span class="built_in">sb</span> = new <span class="keyword">StringBuilder("iphone");</span></span><br><span class="line"><span class="keyword">void </span>foo(<span class="keyword">StringBuilder </span><span class="keyword">builder) </span>&#123;</span><br><span class="line">    <span class="keyword">builder </span>= new <span class="keyword">StringBuilder("ipad");</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br><span class="line"><span class="keyword">foo(sb); </span>// <span class="built_in">sb</span> 没有被改变，还是 <span class="string">"iphone"</span>。</span><br></pre></td></tr></table></figure><p>重点理解为什么，第三个例子和第四个例子结果不同？</p><p>下面是第三个例子的图解：<br><img src="https://pic2.zhimg.com/80/d8b82e07ea21375ca6b300f9162aa95f_hd.jpg" alt><br><code>builder.append(&quot;4&quot;)之后</code><br><img src="https://pic2.zhimg.com/80/ff2ede9c6c55568d42425561f25a0fd7_hd.jpg" alt></p><p>下面是第四个例子的图解：<br><img src="https://pic2.zhimg.com/80/d8b82e07ea21375ca6b300f9162aa95f_hd.jpg" alt><br><code>builder = new StringBuilder(&quot;ipad&quot;);</code> 之后<br><img src="https://pic4.zhimg.com/80/46fa5f10cc135a3ca087dae35a5211bd_hd.jpg" alt></p><h1 id="从局部变量-方法参数开始讲起"><a href="#从局部变量-方法参数开始讲起" class="headerlink" title="从局部变量/方法参数开始讲起"></a>从局部变量/方法参数开始讲起</h1><p>局部变量和方法参数在jvm中的储存方法是相同的，都是在栈上开辟空间来储存的，随着进入方法开辟，退出方法回收。以32位JVM为例，boolean/byte/short/char/int/float以及引用都是分配4字节空间，long/double分配8字节空间。对于每个方法来说，最多占用多少空间是一定的，这在编译时就可以计算好。</p><p>我们都知道JVM内存模型中有，stack和heap的存在，但是更准确的说，是每个线程都分配一个独享的stack，所有线程共享一个heap。对于每个方法的局部变量来说，是绝对无法被其他方法，甚至其他线程的同一方法所访问到的，更遑论修改。当我们在方法中声明一个 int i = 0，或者 Object obj = null 时，仅仅涉及stack，不影响到heap，当我们 new Object() 时，会在heap中开辟一段内存并初始化Object对象。</p><p>当我们将这个对象赋予obj变量时，仅仅是stack中代表obj的那4个字节变更为这个对象的地址。</p><h1 id="数组类型引用和对象："><a href="#数组类型引用和对象：" class="headerlink" title="数组类型引用和对象："></a>数组类型引用和对象：</h1><p>当我们声明一个数组时，如int[] arr = new int[10]，因为数组也是对象，arr实际上是引用，stack上仅仅占用4字节空间，new int[10]会在heap中开辟一个数组对象，然后arr指向它。</p><p>当我们声明一个二维数组时，如 int[][] arr2 = new int[2][4]，arr2同样仅在stack中占用4个字节，会在内存中开辟一个长度为2的，类型为int[]的数组，然后arr2指向这个数组。这个数组内部有两个引用（大小为4字节），分别指向两个长度为4的类型为int的数组。</p><p><img src="https://pic4.zhimg.com/80/v2-6590cb935ae8bf3b7241cb309fe041d7_hd.jpg" alt></p><p>所以当我们传递一个数组引用给一个方法时，数组的元素是可以被改变的，但是无法让数组引用指向新的数组。</p><p>你还可以这样声明：int[][] arr3 = new int[3][]，这时内存情况如下图</p><p><img src="https://pic2.zhimg.com/80/v2-fdc86227021d56a02b559d6485983c71_hd.jpg" alt></p><p>你还可以这样 arr3[0] = new int [5]; arr3[1] = arr2[0];</p><p><img src="https://pic1.zhimg.com/80/v2-fdc5e737a95d625a47d66ab61e4a2f55_hd.jpg" alt></p><h1 id="关于String"><a href="#关于String" class="headerlink" title="关于String"></a>关于String</h1><p>String对象内部仅需要维护三个变量，char[] chars, int startIndex, int length。而chars在某些情况下是可以共用的。但是因为String被设计成为了不可变类型，所以你思考时把String对象简化考虑也是可以的。String str = new String(“hello”)</p><p><img src="https://pic4.zhimg.com/80/v2-a143d0a3594d06f54c6853c46c429e08_hd.jpg" alt></p><p>当然某些JVM实现会把”hello”字面量生成的String对象放到常量池中，而常量池中的对象可以实际分配在heap中，有些实现也许会分配在方法区，当然这对我们理解影响不大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，不要纠结于 Pass By Value 和 Pass By Reference 的字面上的意义，否则很容易陷入所谓的“一切传引用其实本质上是传值”这种并不能解决问题无意义论战中。更何况，要想知道Java到底是传值还是传引用，起码你要先知道传值和传引用的准确含义吧？可是如果你已经知道了这两个名字的准确含义，那么你自己就能判断Java到底是传值还是传引用。这就好像用大学的名词来解释高中的题目，对于初学者根本没有任何意义。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://blog.xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://blog.xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>restful最佳实践</title>
    <link href="https://blog.xiaomo.info/2019/restfulBestUse/"/>
    <id>https://blog.xiaomo.info/2019/restfulBestUse/</id>
    <published>2019-07-22T00:00:00.000Z</published>
    <updated>2020-06-28T16:53:07.143Z</updated>
    
    <content type="html"><![CDATA[<p>restful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计。它的大原则容易把握，但是细节不容易做对。<br><a id="more"></a></p><h4 id="不要纠结于无意义的规范"><a href="#不要纠结于无意义的规范" class="headerlink" title="不要纠结于无意义的规范"></a>不要纠结于无意义的规范</h4><p>  在开始本文之前，我想先说这么一句：RESTful 真的很好，但它只是一种软件架构风格，过度纠结如何遵守规范只是徒增烦恼，也违背了使用它的初衷。</p><p>  就像 Elasticsearch 的 API 会在 GET 请求中直接传 JSON，但这是它的业务需要，因为普通的 Query Param 根本无法构造如此复杂的查询 DSL。Github 的 V3 API 中也有很多不符合标准的地方，这也并不会妨碍它成为业界 RESTful API 的参考标准。</p><p>  我接下来要介绍的一些东西也会跟标准不符，但这是我在实际开发中遇到过、困扰过、思考过所得出的结论，所以才是<q>我所认为的</q>RESTful API 最佳实践。</p><h1 id="为什么要用-RESTful"><a href="#为什么要用-RESTful" class="headerlink" title="为什么要用 RESTful"></a>为什么要用 RESTful</h1><p> RESTful 给我的最大感觉就是规范、易懂和优雅，一个结构清晰、易于理解的 API 完全可以省去许多无意义的沟通和文档。并且 RESTful 现在越来越流行，也有越来越多优秀的周边工具（例如文档工具 Swagger）。</p><h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>  如果能全站 HTTPS 当然是最好的，不能的话也请尽量将登录、注册等涉及密码的接口使用 HTTPS。</p><h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><p> API 的版本号和客户端 APP 的版本号是毫无关系的，不要让 APP 将它们用于提交应用市场的版本号传递到服务器，而是提供类似于<code>v1</code>、<code>v2</code>之类的 API 版本号。版本号只允许枚举，不允许判断区间。</p><p>  版本号拼接在 URL 中或是放在 Header 中都可以。例如：</p> <figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">api.xxx.com</span>/<span class="built_in">v1</span>/users</span><br></pre></td></tr></table></figure><p>  或：</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">api.xxx.com/users</span><br><span class="line"> <span class="attribute">version</span>=v1</span><br></pre></td></tr></table></figure><h1 id="URL-设计"><a href="#URL-设计" class="headerlink" title="URL 设计"></a>URL 设计</h1><h3 id="动词-宾语"><a href="#动词-宾语" class="headerlink" title="动词+宾语"></a>动词+宾语</h3><p>RESTful 的核心思想就是，客户端发出的数据操作指令都是”动词 + 宾语”的结构。比如，GET /articles这个命令，GET是动词，/articles是宾语。<br>动词通常就是五种 HTTP 方法，对应 CRUD 操作。</p><h3 id="动词的覆盖"><a href="#动词的覆盖" class="headerlink" title="动词的覆盖"></a>动词的覆盖</h3><p>有些客户端只能使用GET和POST这两种方法。服务器必须接受POST模拟其他三个方法（PUT、PATCH、DELETE）。<br>这时，客户端发出的 HTTP 请求，要加上X-HTTP-Method-Override属性，告诉服务器应该使用哪一个动词，覆盖POST方法。</p><h3 id="宾语必须是名词"><a href="#宾语必须是名词" class="headerlink" title="宾语必须是名词"></a>宾语必须是名词</h3><p>宾语就是 API 的 URL，是 HTTP 动词作用的对象。它应该是名词，不能是动词。比如，/articles这个 URL 就是正确的，而下面的 URL 不是名词，所以都是错误的。</p><h3 id="复数-URL"><a href="#复数-URL" class="headerlink" title="复数 URL"></a>复数 URL</h3><p>既然 URL 是名词，那么应该使用复数，还是单数？<br>这没有统一的规定，但是常见的操作是读取一个集合，比如GET /articles（读取所有文章），这里明显应该是复数。<br>为了统一起见，建议都使用复数 URL，比如GET /articles/2要好于GET /article/2。</p><h3 id="避免多级-URL"><a href="#避免多级-URL" class="headerlink" title="避免多级 URL"></a>避免多级 URL</h3><p>常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">GET <span class="regexp">/authors/</span><span class="number">12</span><span class="regexp">/categories/</span><span class="number">2</span></span><br></pre></td></tr></table></figure><p>这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。<br>更好的做法是，除了第一级，其他级别都用查询字符串表达。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /authors/12?<span class="attribute">categories</span>=2</span><br></pre></td></tr></table></figure><h1 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h1><p>一般来说 API 的外在形式无非就是增删改查（当然具体的业务逻辑肯定要复杂得多），而查询又分为详情和列表两种，在 RESTful 中这就相当于通用的模板。例如针对文章（Article）设计 API，那么最基础的 URL 就是这几种：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">GET <span class="meta-keyword">/articles/</span>list： 文章列表</span><br><span class="line">GET <span class="meta-keyword">/articles/</span>detail<span class="class">/&#123;id&#125;：文章详情</span></span><br><span class="line"><span class="class">POST <span class="meta-keyword">/articles/</span>create/： 创建文章</span></span><br><span class="line"><span class="class">PUT <span class="meta-keyword">/articles/</span>update/&#123;id&#125;：修改文章</span></span><br><span class="line"><span class="class">DELETE <span class="meta-keyword">/articles/</span>delete/&#123;id&#125;：删除文章</span></span><br></pre></td></tr></table></figure><p> RESTful 中使用 GET、POST、PUT 和 DELETE 来表示资源的查询、创建、更改、删除，并且除了 POST 其他三种请求都具备幂等性（多次请求的效果相同）。需要注意的是 POST 和 PUT 最大的区别就是幂等性，所以 PUT 也可以用于创建操作，只要在创建前就可以确定资源的 id。</p><p>  将 id 放在 URL 中而不是 Query Param 的其中一个好处是可以表示资源之间的层级关系，例如文章下面会有评论（Comment）和点赞（Like），这两项资源必然会属于一篇文章，所以它们的 URL 应该是这样的：</p><p>评论：<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">GET <span class="string">/articles/</span>&#123;aid&#125;<span class="string">/comments</span>： 某篇文章的评论列表</span><br><span class="line">GET <span class="string">/comments/</span>&#123;cid&#125;<span class="string">/get</span>： 获取</span><br><span class="line">POST <span class="string">/articles/</span>&#123;aid&#125;<span class="string">/comments/create</span>： 在某篇文章中创建评论</span><br><span class="line">PUT <span class="string">/comments/</span>&#123;cid&#125;<span class="string">/update</span>： 修改评论</span><br><span class="line">DELETE <span class="string">/comments/</span>&#123;cid&#125;<span class="string">/delete</span>： 删除评论</span><br></pre></td></tr></table></figure></p><p>  这里有一点比较特殊，永远去使用可以指向资源的的最短 URL 路径，也就是说既然<code>/comments/{cid}</code>已经可以指向一条评论了，就不需要再用<code>/articles/{aid}/comments/{cid}</code>特意的指出所属文章了。</p><p>点赞：<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">GET <span class="string">/articles/</span>&#123;id&#125;<span class="string">/like</span>：查看文章是否被点赞</span><br><span class="line">PUT <span class="string">/articles/</span>&#123;id&#125;<span class="string">/like</span>：点赞文章</span><br><span class="line">DELETE <span class="string">/articles/</span>&#123;id&#125;<span class="string">/like</span>：取消点赞</span><br></pre></td></tr></table></figure></p><p>由于大部分的关系查询都与当前的登录用户有关，所以也可以直接在关系所属的资源中返回关系状态。例如点赞状态就可以直接在获取文章详情时返回。注意这里我选择了 PUT 而不是 POST，因为我觉得点赞这种行为应该是幂等的，多次操作的结果应该相同。</p><h1 id="Token-和-Sign"><a href="#Token-和-Sign" class="headerlink" title="Token 和 Sign"></a>Token 和 Sign</h1><p>API 需要设计成无状态，所以客户端在每次请求时都需要提供有效的 Token 和 Sign，在我看来它们的用途分别是：</p><ul><li>Token 用于证明请求所属的用户，一般都是服务端在登录后随机生成一段字符串（UUID）和登录用户进行绑定，再将其返回给客户端。Token 的状态保持一般有两种方式实现：一种是在用户每次操作都会延长或重置 TOKEN 的生存时间（类似于缓存的机制），另一种是 Token 的生存时间固定不变，但是同时返回一个刷新用的 Token，当 Token 过期时可以将其刷新而不是重新登录。</li><li>Sign 用于证明该次请求合理，所以一般客户端会把请求参数拼接后并加密作为 Sign 传给服务端，这样即使被抓包了，对方只修改参数而无法生成对应的 Sign 也会被服务端识破。当然也可以将时间戳、请求地址和 Token 也混入 Sign，这样 Sign 也拥有了所属人、时效性和目的地。</li></ul><h1 id="统计性参数"><a href="#统计性参数" class="headerlink" title="统计性参数"></a>统计性参数</h1><p>  我不太清楚这类参数具体该被称为什么，总之就是用户的各种隐私【误。类似于经纬度、手机系统、型号、IMEI、网络状态、客户端版本、渠道等，这些参数会经常收集然后用作运营、统计等平台，但是在大部分情况下他们是与业务无关的。这类参数变化不频繁的可以在登录时提交，变化比较频繁的可以用轮训或是在其他请求中附加提交。</p><h1 id="业务参数"><a href="#业务参数" class="headerlink" title="业务参数"></a>业务参数</h1><p>  在 RESTful 的标准中，PUT 和 PATCH 都可以用于修改操作，它们的区别是 PUT 需要提交整个对象，而 PATCH 只需要提交修改的信息。但是在我看来实际应用中不需要这么麻烦，所以我一律使用 PUT，并且只提交修改的信息。<br>  另一个问题是在 POST 创建对象时，究竟该用表单提交更好些还是用 JSON 提交更好些。其实两者都可以，在我看来它们唯一的区别是 JSON 可以比较方便的表示更为复杂的结构（有嵌套对象）。另外无论使用哪种，请保持统一，不要两者混用。<br>  还有一个建议是最好将过滤、分页和排序的相关信息全权交给客户端，包括过滤条件、页数或是游标、每页的数量、排序方式、升降序等，这样可以使 API 更加灵活。但是对于过滤条件、排序方式等，不需要支持所有方式，只需要支持目前用得上的和以后可能会用上的方式即可，并通过字符串枚举解析，这样可见性要更好些。例如：<br>  搜索，客户端只提供关键词，具体搜索的字段，和搜索方式（前缀、全文、精确）由服务端决定：</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">/users/?<span class="attribute">query</span>=ScienJus</span><br></pre></td></tr></table></figure><p>  过滤，只需要对已有的情况进行支持：</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">/users/?<span class="attribute">gender</span>=1</span><br></pre></td></tr></table></figure><p>  对于某些特定且复杂的业务逻辑，不要试图让客户端用复杂的查询参数表示，而是在 URL 使用别名：</p> <figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/users/</span>recommend</span><br></pre></td></tr></table></figure><p>  分页：</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">/users/?<span class="attribute">offset</span>=10&amp;limit=10</span><br><span class="line"> /articles/?<span class="attribute">cursor</span>=2015-01-01 15:20:30&amp;<span class="attribute">limit</span>=10</span><br><span class="line"> /users/?<span class="attribute">page</span>=2&amp;pre_page=20</span><br></pre></td></tr></table></figure><p>  排序，只需要对已有的情况进行支持：</p> <figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/articles/</span><span class="keyword">sort</span>=-create_date</span><br></pre></td></tr></table></figure><p> PS：我很喜欢这种在字段名前面加<code>-</code>表示降序排列的方式。</p><h1 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h1><p>HTTP 状态码就是一个三位数，分成五个类别。</p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>xx：相关信息</span><br><span class="line"><span class="number">2</span>xx：操作成功</span><br><span class="line"><span class="number">3</span>xx：重定向</span><br><span class="line"><span class="number">4</span>xx：客户端错误</span><br><span class="line"><span class="number">5</span>xx：服务器错误</span><br></pre></td></tr></table></figure><p>这五大类总共包含100多种状态码，覆盖了绝大部分可能遇到的情况。每一种状态码都有标准的（或者约定的）解释，客户端只需查看状态码，就可以判断出发生了什么情况，所以服务器应该返回尽可能精确的状态码。<br>API 不需要1xx状态码，下面介绍其他四类状态码的精确含义。</p><h3 id="2xx-状态码"><a href="#2xx-状态码" class="headerlink" title="2xx 状态码"></a>2xx 状态码</h3><p>200状态码表示操作成功，但是不同的方法可以返回更精确的状态码。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">GET:</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">POST:</span> <span class="number">201</span> <span class="string">Created</span></span><br><span class="line"><span class="attr">PUT:</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">PATCH:</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">DELETE:</span> <span class="number">204</span> <span class="literal">No</span> <span class="string">Content</span></span><br></pre></td></tr></table></figure><p>上面代码中，POST返回201状态码，表示生成了新的资源；DELETE返回204状态码，表示资源已经不存在。<br>此外，202 Accepted状态码表示服务器已经收到请求，但还未进行处理，会在未来再处理，通常用于异步操作。下面是一个例子</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">202</span> Accepted</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "task": &#123;</span><br><span class="line">    "href": "/api/company/job-management/jobs/2130040",</span><br><span class="line">    "id": "2130040"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3xx-状态码"><a href="#3xx-状态码" class="headerlink" title="3xx 状态码"></a>3xx 状态码</h3><p>API 用不到301状态码（永久重定向）和302状态码（暂时重定向，307也是这个含义），因为它们可以由应用级别返回，浏览器会直接跳转，API 级别可以不考虑这两种情况。<br>API 用到的3xx状态码，主要是303 See Other，表示参考另一个 URL。它与302和307的含义一样，也是”暂时重定向”，区别在于302和307用于GET请求，而303用于POST、PUT和DELETE请求。收到303以后，浏览器不会自动跳转，而会让用户</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">303</span> See Other</span><br><span class="line"><span class="attribute">Location</span>: /api/orders/12345</span><br></pre></td></tr></table></figure><h3 id="4xx-状态码"><a href="#4xx-状态码" class="headerlink" title="4xx 状态码"></a>4xx 状态码</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>xx状态码表示客户端错误，主要有下面几种。</span><br><span class="line"><span class="symbol">400 </span>Bad Request：服务器不理解客户端的请求，未做任何处理。</span><br><span class="line"><span class="symbol">401 </span>Unauthorized：用户未提供身份验证凭据，或者没有通过身份验证。</span><br><span class="line"><span class="symbol">403 </span>Forbidden：用户通过了身份验证，但是不具有访问资源所需的权限。</span><br><span class="line"><span class="symbol">404 </span><span class="keyword">Not</span> Found：所请求的资源不存在，或不可用。</span><br><span class="line"><span class="symbol">405 </span>Method <span class="keyword">Not</span> Allowed：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。</span><br><span class="line"><span class="symbol">410 </span>Gone：所请求的资源已从这个地址转移，不再可用。</span><br><span class="line"><span class="symbol">415 </span>Unsupported Media Type：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。</span><br><span class="line"><span class="symbol">422 </span>Unprocessable Entity ：客户端上传的附件无法处理，导致请求失败。</span><br><span class="line"><span class="symbol">429 </span>Too Many Requests：客户端的请求次数超过限额。</span><br></pre></td></tr></table></figure><h3 id="5xx-状态码"><a href="#5xx-状态码" class="headerlink" title="5xx 状态码"></a>5xx 状态码</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>xx状态码表示服务端错误。一般来说，API 不会向用户透露服务器的详细信息，所以只要两个状态码就够了。</span><br><span class="line"><span class="symbol">500 </span>Internal Server <span class="keyword">Error</span>：客户端请求有效，服务器处理时发生了意外。</span><br><span class="line"><span class="symbol">503 </span>Service Unavailable：服务器无法处理请求，一般用于网站维护状态。</span><br></pre></td></tr></table></figure><p>  但是有些时候仅仅使用 HTTP 状态码没有办法明确的表达错误信息，所以我倾向于在里面再包一层自定义的返回码，例如：</p><p>  成功时：</p> <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"成功"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  失败时：</p> <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">-1000</span>,</span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"用户名或密码错误"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>data</code>是真正需要返回的数据，并且只会在请求成功时才存在，<code>msg</code>只用在开发环境，并且只为了开发人员识别。客户端逻辑只允许识别<code>code</code>，并且不允许直接将<code>msg</code>的内容展示给用户。如果这个错误很复杂，无法使用一段话描述清楚，也可以在添加一个<code>doc</code>字段，包含指向该错误的文档的链接。</p><h1 id="返回数据"><a href="#返回数据" class="headerlink" title="返回数据"></a>返回数据</h1><h3 id="不要返回纯本文"><a href="#不要返回纯本文" class="headerlink" title="不要返回纯本文"></a>不要返回纯本文</h3><p>API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的Content-Type属性要设为application/json。<br>客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的ACCEPT属性也要设成application/json。下面是一个例子。</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">GET <span class="meta-keyword">/orders/</span><span class="number">2</span> HTTP/<span class="number">1.1</span> </span><br><span class="line"><span class="symbol">Accept:</span> application/json</span><br></pre></td></tr></table></figure><h3 id="发生错误时，不要返回-200-状态码"><a href="#发生错误时，不要返回-200-状态码" class="headerlink" title="发生错误时，不要返回 200 状态码"></a>发生错误时，不要返回 200 状态码</h3><p>有一种不恰当的做法是，即使发生错误，也返回200状态码，把错误信息放在数据体里面，就像下面这样。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "status": "failure",</span><br><span class="line">  "data": &#123;</span><br><span class="line">    "error": "Expected at least two items in list."</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，解析数据体以后，才能得知操作失败。<br>这张做法实际上取消了状态码，这是完全不可取的。正确的做法是，状态码反映发生的错误，具体的错误信息放在数据体里面返回。下面是一个例子。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">HTTP/1.1 <span class="number">400</span> Bad Request</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "error": "Invalid payoad.",</span><br><span class="line">  "detail": &#123;</span><br><span class="line">     "surname": "This field is required."</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提供链接"><a href="#提供链接" class="headerlink" title="提供链接"></a>提供链接</h3><p>API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 HATEOAS。<br>举例来说，GitHub 的 API 都在 api.github.com 这个域名。访问它，就可以得到其他 URL。</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="string">"feeds_url"</span>: <span class="string">"https://api.github.com/feeds"</span>,</span><br><span class="line">  <span class="string">"followers_url"</span>: <span class="string">"https://api.github.com/user/followers"</span>,</span><br><span class="line">  <span class="string">"following_url"</span>: <span class="string">"https://api.github.com/user/following&#123;/target&#125;"</span>,</span><br><span class="line">  <span class="string">"gists_url"</span>: <span class="string">"https://api.github.com/gists&#123;/gist_id&#125;"</span>,</span><br><span class="line">  <span class="string">"hub_url"</span>: <span class="string">"https://api.github.com/hub"</span>,</span><br><span class="line">  <span class="string">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的回应中，挑一个 URL 访问，又可以得到别的 URL。对于用户来说，不需要记住 URL 设计，只要从 api.github.com 一步步查找就可以了。</p><p>HATEOAS 的格式没有统一规定，上面例子中，GitHub 将它们与其他属性放在一起。更好的做法应该是，将相关链接与其他属性分开。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "status": "In progress",</span><br><span class="line">   "links": &#123;[</span><br><span class="line">    &#123; "rel":"cancel", "method": "delete", "href":"/api/status/12345" &#125; ,</span><br><span class="line">    &#123; "rel":"edit", "method": "put", "href":"/api/status/12345" &#125;</span><br><span class="line">  ]&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSON 比 XML 可视化更好，也更加节约流量，所以尽量不要使用 XML。<br>创建和修改操作成功后，需要返回该资源的全部信息。<br>返回数据不要和客户端界面强耦合，不要在设计 API 时就考虑少查询一张关联表或是少查询 / 返回几个字段能带来多大的性能提升。并且一定要以资源为单位，即使客户端一个页面需要展示多个资源，也不要在一个接口中全部返回，而是让客户端分别请求多个接口。<br>最好将返回数据进行加密和压缩，尤其是压缩在移动应用中还是比较重要的。</p><h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p>  在 <a href="http://www.scienjus.com/app-server-paging/" target="_blank" rel="noopener">APP 后端分页设计</a> 中提到过，分页布局一般分为两种，一种是在 Web 端比较常见的有底部分页栏的电梯式分页，另一种是在 APP 中比较常见的上拉加载更多的流式分页。这两种分页的 API 到底该如何设计呢？</p><p>  电梯式分页需要提供<code>page</code>（页数）和<code>pre_page</code>（每页的数量）。例如：</p> <figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta-keyword">/users/</span>?page=<span class="number">2</span><span class="variable">&amp;pre_page</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure><p>  而服务端则需要额外返回<code>total_count</code>（总记录数），以及可选的当前页数、每页的数量（这两个与客户端提交的相同）、总页数、是否有下一页、是否有上一页（这三个都可以通过总记录数计算出）。例如：</p> <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"pagination"</span>: &#123;</span><br><span class="line">       <span class="attr">"previous"</span>: <span class="number">1</span>,</span><br><span class="line">       <span class="attr">"next"</span>: <span class="number">3</span>,</span><br><span class="line">       <span class="attr">"current"</span>: <span class="number">2</span>,</span><br><span class="line">       <span class="attr">"per_page"</span>: <span class="number">20</span>,</span><br><span class="line">       <span class="attr">"total"</span>: <span class="number">200</span>,</span><br><span class="line">       <span class="attr">"pages"</span>: <span class="number">10</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"data"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  流式布局也完全可以使用这种方式，并且不需要查询总记录数（好处是减少一次数据库操作，坏处时客户端需要多请求一次才能判断是否到最后一页）。但是会出现数据重复和缺失的情况，所以更推荐使用游标分页。</p><p>  游标分页需要提供<code>cursor</code>(下一页的起点游标) 和<code>limit</code>(数量) 参数。例如：</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">/articles/?<span class="attribute">cursor</span>=2015-01-01 15:20:30&amp;<span class="attribute">limit</span>=10</span><br></pre></td></tr></table></figure><p>  如果文章列表默认是以创建时间为倒序排列的，那么<code>cursor</code>就是当前列表最后一条的创建时间（第一页为当前时间）。</p><p>  服务端需要返回的数据也很简单，只需要以此游标为起点的总记录数和下一个起点游标就可以了。例如：</p> <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"pagination"</span>: &#123;</span><br><span class="line">       <span class="attr">"next"</span>: <span class="string">"2015-01-01 12:20:30"</span>,</span><br><span class="line">       <span class="attr">"limit"</span>: <span class="number">10</span>,</span><br><span class="line">       <span class="attr">"total"</span>: <span class="number">100</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"data"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如果<code>total</code>小于<code>limit</code>，就说明已经没有数据了。</p><p>  流式布局的分页 API 还有一种情况很常见，就是下拉刷新的增量更新。它的业务逻辑正好和游标分页相反，但是参数基本一样：</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">/articles/?<span class="attribute">cursor</span>=2015-01-01 15:20:30&amp;<span class="attribute">limit</span>=20</span><br></pre></td></tr></table></figure><p>  返回数据有两种可能，一种是增量更新的数据小于指定的数量，就直接将全部数据返回（这个数量可以设置的相对大一些），客户端会将这些增量更新的数据添加在已有列表的顶部。但是如果增量更新的数据要大于指定的数量，就会只返回最新的 n 条数据作为第一页，这时候客户端需要清空之前的列表。例如：</p> <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"pagination"</span>: &#123;</span><br><span class="line">       <span class="attr">"limit"</span>: <span class="number">20</span>,</span><br><span class="line">       <span class="attr">"total"</span>: <span class="number">100</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"data"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如果<code>total</code>大于<code>limit</code>，说明增量的数据太多所以只返回了第一页，需要清空旧的列表。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;restful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计。它的大原则容易把握，但是细节不容易做对。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://blog.xiaomo.info/categories/java/"/>
    
    
      <category term="java" scheme="https://blog.xiaomo.info/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>jdk源码系列-Thread.sleep(0)和Thread.sleep(1)的区别</title>
    <link href="https://blog.xiaomo.info/2019/jdkSourceCodeReadThreadSleep/"/>
    <id>https://blog.xiaomo.info/2019/jdkSourceCodeReadThreadSleep/</id>
    <published>2019-07-22T00:00:00.000Z</published>
    <updated>2020-06-28T16:53:07.143Z</updated>
    
    <content type="html"><![CDATA[<p>某人的代码中用了一句看似莫明其妙的话：Thread.Sleep(0) 。既然是 Sleep 0 毫秒，那么他跟去掉这句代码相比，有啥区别么？Thread.Sleep(0) 表示挂起0毫秒，你可能觉得没作用，你要写Thread.Sleep(1000) 就有感觉了。<br><a id="more"></a></p><p>Thread.Sleep(0) 并非是真的要线程挂起0毫秒，意义在于这次调用Thread.Sleep(0)的当前线程确实的被冻结了一下，让其他线程有机会优先执行。Thread.Sleep(0) 是你的线程暂时放弃cpu，也就是释放一些未用的时间片给其他线程或进程使用，就相当于一个让位动作。<br>在线程中，调用sleep（0）可以释放cpu时间，让线程马上重新回到就绪队列而非等待队列，sleep(0)释放当前线程所剩余的时间片（如果有剩余的话），这样可以让操作系统切换其他线程来执行，提升效率。<br>我们可能经常会用到 Thread.Sleep 函数来使线程挂起一段时间。那么你有没有正确的理解这个函数的用法呢？</p><h1 id="回顾一下操作系统原理"><a href="#回顾一下操作系统原理" class="headerlink" title="回顾一下操作系统原理"></a>回顾一下操作系统原理</h1><p>操作系统中，CPU竞争有很多种策略。Unix系统使用的是时间片算法，而Windows则属于抢占式的。<br>在时间片算法中，所有的进程排成一个队列。操作系统按照他们的顺序，给每个进程分配一段时间，即该进程允许运行的时间。如果在 时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程 序所要做的就是维护一张就绪进程列表，，当进程用完它的时间片后，它被移到队列的末尾。</p><p>所谓抢占式操作系统，就是说如果一个进程得到了 CPU 时间，除非它自己放弃使用 CPU ，否则将完全霸占 CPU 。因此可以看出，在抢 占式操作系统中，操作系统假设所有的进程都是“人品很好”的，会主动退出 CPU 。在抢占式操作系统中，假设有若干进程，操作系统会根据他们的优先级、饥饿时间（已经多长时间没有使用过 CPU 了），给他们算出一 个总的优先级来。操作系统就会把 CPU 交给总优先级最高的这个进程。当进程执行完毕或者自己主动挂起后，操作系统就会重新计算一 次所有进程的总优先级，然后再挑一个优先级最高的把 CPU 控制权交给他。</p><p>我们用分蛋糕的场景来描述这两种算法。假设有源源不断的蛋糕（源源不断的时间），一副刀叉（一个CPU），10个等待吃蛋糕的人（10 个进程）。<br>如果是 Unix操作系统来负责分蛋糕，那么他会这样定规矩：每个人上来吃 1 分钟，时间到了换下一个。最后一个人吃完了就再从头开始。于是，不管这10个人是不是优先级不同、饥饿程度不同、饭量不同，每个人上来的时候都可以吃 1 分钟。当然，如果有人本来不太饿，或者饭量小，吃了30秒钟之后就吃饱了，那么他可以跟操作系统说：我已经吃饱了（挂起）。于是操作系统就会让下一个人接着来。<br>如果是 Windows 操作系统来负责分蛋糕的，那么场面就很有意思了。他会这样定规矩：我会根据你们的优先级、饥饿程度去给你们每个人计算一个优先级。优先级最高的那个人，可以上来吃蛋糕——吃到你不想吃为止。等这个人吃完了，我再重新根据优先级、饥饿程度来计算每个人的优先级，然后再分给优先级最高的那个人。<br>这样看来，这个场面就有意思了——可能有些人是PPMM，因此具有高优先级，于是她就可以经常来吃蛋糕。可能另外一个人是个丑男，而去很ws，所以优先级特别低，于是好半天了才轮到他一次（因为随着时间的推移，他会越来越饥饿，因此算出来的总优先级就会越来越高，因此总有一天会轮到他的）。而且，如果一不小心让一个大胖子得到了刀叉，因为他饭量大，可能他会霸占着蛋糕连续吃很久很久，导致旁边的人在那里咽口水。。。</p><p>而且，还可能会有这种情况出现：操作系统现在计算出来的结果，5号PPMM总优先级最高，而且高出别人一大截。因此就叫5号来吃蛋糕。5号吃了一小会儿，觉得没那么饿了，于是说“我不吃了”（挂起）。因此操作系统就会重新计算所有人的优先级。因为5号刚刚吃过，因此她的饥饿程度变小了，于是总优先级变小了；而其他人因为多等了一会儿，饥饿程度都变大了，所以总优先级也变大了。不过这时候仍然有可能5号的优先级比别的都高，只不过现在只比其他的高一点点——但她仍然是总优先级最高的啊。因此操作系统就会说：5号mm上来吃蛋糕……（5号mm心里郁闷，这不刚吃过嘛……人家要减肥……谁叫你长那么漂亮，获得了那么高的优先级）。</p><p>那么，Thread.Sleep 函数是干吗的呢？还用刚才的分蛋糕的场景来描述。上面的场景里面，5号MM在吃了一次蛋糕之后，觉得已经有8分饱了，她觉得在未来的半个小时之内都不想再来吃蛋糕了，那么她就会跟操作系统说：在未来的半个小时之内不要再叫我上来吃蛋糕了。这样，操作系统在随后的半个小时里面重新计算所有人总优先级的时候，就会忽略5号mm。Sleep函数就是干这事的，他告诉操作系统“在未来的多少毫秒内我不参与CPU竞争”。</p><p>看完了 Thread.Sleep 的作用，我们再来想想文章开头的两个问题。<br>对于第一个问题，答案是：不一定。因为你只是告诉操作系统：在未来的1000毫秒内我不想再参与到CPU竞争。那么1000毫秒过去之后，这时候也许另外一个线程正在使用CPU，那么这时候操作系统是不会重新分配CPU的，直到那个线程挂起或结束；况且，即使这个时候恰巧轮到操作系统进行CPU 分配，那么当前线程也不一定就是总优先级最高的那个，CPU还是可能被其他线程抢占去。与此相似的，Thread有个Resume函数，是用来唤醒挂起的线程的。好像上面所说的一样，这个函数只是“告诉操作系统我从现在起开始参与CPU竞争了”，这个函数的调用并不能马上使得这个线程获得CPU控制权。</p><p>对于第二个问题，答案是：有，而且区别很明显。假设我们刚才的分蛋糕场景里面，有另外一个PPMM 7号，她的优先级也非常非常高（因为非常非常漂亮），所以操作系统总是会叫道她来吃蛋糕。而且，7号也非常喜欢吃蛋糕，而且饭量也很大。不过，7号人品很好，她很善良，她没吃几口就会想：如果现在有别人比我更需要吃蛋糕，那么我就让给他。因此，她可以每吃几口就跟操作系统说：我们来重新计算一下所有人的总优先级吧。不过，操作系统不接受这个建议——因为操作系统不提供这个接口。于是7号mm就换了个说法：“在未来的0毫秒之内不要再叫我上来吃蛋糕了”。这个指令操作系统是接受的，于是此时操作系统就会重新计算大家的总优先级——注意这个时候是连7号一起计算的，因为“0毫秒已经过去了”嘛。因此如果没有比7号更需要吃蛋糕的人出现，那么下一次7号还是会被叫上来吃蛋糕。<br>因此，Thread.Sleep(0)的作用，就是“触发操作系统立刻重新进行一次CPU竞争”。竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。这也是我们在大循环里面经常会写一句Thread.Sleep(0) ，因为这样就给了其他线程比如Paint线程获得CPU控制权的权力，这样界面就不会假死在那里。</p><p>末了说明一下，虽然上面提到说“除非它自己放弃使用 CPU ，否则将完全霸占 CPU”，但这个行为仍然是受到制约的——操作系统会监控你霸占CPU的情况，如果发现某个线程长时间霸占CPU，会强制使这个线程挂起，因此在实际上不会出现“一个线程一直霸占着 CPU 不放”的情况。至于我们的大循环造成程序假死，并不是因为这个线程一直在霸占着CPU。实际上在这段时间操作系统已经进行过多次CPU竞争了，只不过其他线程在获得CPU控制权之后很短时间内马上就退出了，于是就又轮到了这个线程继续执行循环，于是就又用了很久才被操作系统强制挂起。。。因此反应到界面上，看起来就好像这个线程一直在霸占着CPU一样。<br>末了再说明一下，文中线程、进程有点混乱，其实在Windows原理层面，CPU竞争都是线程级的，本文中把这里的进程、线程看成同一个东西就好了。</p><h1 id="问题：主动的放弃运行让系统调度的意义是什么呢？"><a href="#问题：主动的放弃运行让系统调度的意义是什么呢？" class="headerlink" title="问题：主动的放弃运行让系统调度的意义是什么呢？"></a>问题：主动的放弃运行让系统调度的意义是什么呢？</h1><p>为了等待资源、事件，那么你需要进入等待队列。如果你已经拥有运行所需资源，却让系统调度，这是资源的浪费，并且调度也是要浪费资源的</p><p>解释：对的，你要等待资源，你确实需要排队，假如AB两个线程为合作关系，A线程处理一些原始数据，数据处理到一定程度，交给B线程处理，在A处理原始数据的时候，B也要做一些准备工作，所以，AB是并发的，但是B做好准备之后，需要等待A处理好那些数据，接过A的数据，继续处理，因此，这个等待，如果A不使用信号或者等待条件来通知B的话，那么B必须一直轮询，查看A是否已完成，B线程所做的这个轮询是否会一直占用CPU来做无用的循环查看呢？因此B这个时候占用的cpu时间片做的是无用功，因此，这里sleep(0)就有作用，当B查看A没处理完数据的时候，B马上sleep(0)交出B的时间片，让操作系统调度A来运行(假设只有AB两个线程），那么这个时候，A就会得到充分的时间来处理它的数据，这个不是一个应用了吗？我猜测pthread_conn_wait()内部阻塞就是使用这个机制</p><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">thread_fun</span>()</span><br><span class="line">&#123;</span><br><span class="line">    prepare_word.....</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A is finish)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">0</span>); <span class="comment">//这里会交出B的时间片，下一次调度B的时候，接着执行这个循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    process A's data</span><br></pre></td></tr></table></figure><p>没有sleep(0)版：<br><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">thread_fun</span>()</span><br><span class="line">&#123;</span><br><span class="line">    prepare_word.....</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)  <span class="comment">//这里会一直浪费CPU时间做死循环的轮询，无用功</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A is finish)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    process A's data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果说是轮询，那它就是一种高效、节约、谦虚的轮询，如果没有sleep(0)，那么B线程可能会执行上万次的while循环，直至它的时间片消耗完，做这些都是无用功，而是用了sleep(0)后，B线程每一次执行就只做一次while循环就把剩余的时间片让出给A，能让A得到更多的执行次数,利用率更高</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>在线程没退出之前，线程有三个状态，就绪态，运行态，等待态。sleep(n)之所以在n秒内不会参与CPU竞争，是因为，当线程调用sleep(n)的时候，线程是由运行态转入等待态，线程被放入等待队列中，等待定时器n秒后的中断事件，当到达n秒计时后，线程才重新由等待态转入就绪态，被放入就绪队列中，等待队列中的线程是不参与cpu竞争的，只有就绪队列中的线程才会参与cpu竞争，所谓的cpu调度，就是根据一定的算法（优先级，FIFO等。。。），从就绪队列中选择一个线程来分配cpu时间。</p><p>而sleep(0)之所以马上回去参与cpu竞争，是因为调用sleep(0)后，因为0的原因，线程直接回到就绪队列，而非进入等待队列，只要进入就绪队列，那么它就参与cpu竞争。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;某人的代码中用了一句看似莫明其妙的话：Thread.Sleep(0) 。既然是 Sleep 0 毫秒，那么他跟去掉这句代码相比，有啥区别么？Thread.Sleep(0) 表示挂起0毫秒，你可能觉得没作用，你要写Thread.Sleep(1000) 就有感觉了。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://blog.xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://blog.xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>小莫的日本换驾照攻略</title>
    <link href="https://blog.xiaomo.info/2019/nihonnmennkyo/"/>
    <id>https://blog.xiaomo.info/2019/nihonnmennkyo/</id>
    <published>2019-05-31T00:00:00.000Z</published>
    <updated>2020-06-28T16:53:07.143Z</updated>
    
    <content type="html"><![CDATA[<p>虽然没有100%确定要在日本定居，但是也不能像咸鱼一样度日。而且日本的驾照可以作为身份证明使用（有些日企在填资料时有一项是填：是否有驾照），所以便有准备考驾照，当然以后自驾游啥的也是很方便。在准备考试的过程中经过多方了解和调查获取了许多相关知识，所以准备以blog的形式记录下来。一是把内容整理出来方便自己更好的通过考试，也可以方便在日本想要换驾照的朋友提供个参照。（本篇文章历时2周，花费时间5个小时左右）<br><a id="more"></a></p><h1 id="换驾照和住所有关"><a href="#换驾照和住所有关" class="headerlink" title="换驾照和住所有关"></a>换驾照和住所有关</h1><p>因为我住在琦玉，所以换驾照是去<code>埼玉県鴻巣市鴻巣405番地</code>警察署，具体移步<a href="https://www.police.pref.saitama.lg.jp/f0130/menkyo/gaikoku.html" target="_blank" rel="noopener">琦玉警察署</a>，还有一种不需要和住所绑定，也就是报一个华人驾校，费用在3-4万左右。由于我准备硬刚，所以没有做这种方式的相关攻略，我同事选的这个方式目前己拿到驾照。如果万一对自己没有信心的话可以找个技能学习中心学几节课，费用在2万左右。不管怎么说换驾照都比直接考要便宜，我有个朋友10连休去学的驾照花了20多万，12天拿到驾照。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li>资料审核时间是工作日的早上9:30-10:30,和下午的1:30-2:00，各半小时（政府单位就是这么任性）。如果要当天考视力和笔试必须得上午去，下午1点钟考。</li><li>在国内拿到驾照之后需要待满3个月以上才能过来换。</li><li>如果日语不好需要有人陪同，会问一些简单的情况。</li><li>如果戴眼镜的话会被做标记限制只能戴眼镜开车，很在意这个测视力的时候可以戴隐形假装自己不近视。（看的别人的攻略，个人觉得没必要这样弄虚作假）</li><li>考试内容的话概括是视力测试;10道题的理论测试，7道以上合格;类似国内科二跑一圈。扣分制，70分以下考官会叫停。</li><li>日本是右舵，跟国内相反。不过看到这个攻略的人应该都知道这个情况。</li><li>台湾护照可以不经过考试直接换日本驾照。</li></ol><h1 id="费用"><a href="#费用" class="headerlink" title="费用"></a>费用</h1><ol><li>报名费 2550　（意味着挂几次就要出几次2550）</li><li>领取驾照 2050 （工本费，考过后出一次）</li></ol><h1 id="需要的资料"><a href="#需要的资料" class="headerlink" title="需要的资料"></a>需要的资料</h1><ol><li>在留卡原件</li><li>护照。用来确认在居留期限及出入国境的记录。</li><li>1寸照片（3X2.4），两张或以上。日本的车站里的写真机器或者便利店里的打印机都可以弄。</li><li>登录所有信息的住民票</li><li>中国驾驶证。（原件。JAF及各县交通局会拿去复印。需要在取证之后的3个月内没有出中国的记录。）</li><li>JAF（Japan Automobile Federation日本汽车联盟）翻译件，可以去JAF窗口也可以邮寄。费用 3500，具体请移步<a href="http://www.jaf.or.jp/inter/translation/" target="_blank" rel="noopener">JAF</a></li><li>国内的成绩单和个人信息表，不需要翻译件</li></ol><h1 id="中文PDF说明文件"><a href="#中文PDF说明文件" class="headerlink" title="中文PDF说明文件"></a>中文PDF说明文件</h1><p><a href="https://www.keishicho.metro.tokyo.jp/multilingual/chinese/traffic_safety/drivers_licenses/index.files/convert_license_chinese.pdf" target="_blank" rel="noopener">外国驾照更换日本驾照</a></p><h1 id="考试经过"><a href="#考试经过" class="headerlink" title="考试经过"></a>考试经过</h1><ol><li>坐电梯上2楼右转再右转，到<code>外国人免许相谈室</code>门口排队，等待资料审核。会问一些国内考驾照的细节，需要有一定的日语基础。（不会日语需要自带翻译）</li><li>下午1点前到1楼大厅左侧3-4号排队检查视力，然后考10道理论题，7道以上合格。（正常人都能通过）</li><li>通过之后就会被带到场地上车考试，场地有很多小牌子，考官会提前发出指令。对牌子的位置不熟的话很快就会挂掉！！！<a href="https://blog.xiaomo.info/2019/nihonnmennkyo/#最后配一张琦玉考试的平面路线图">参考</a></li><li>我在考到一半的时候被叫停挂掉，最大原因就是对场地不熟悉（毕竟没练过），开车的时候不停的在找牌子就这样挂掉了，预约在半个月后（6/24）再次考试。</li><li>参考考试结果觉得不练一下还是比较难考过，果断找了一家驾校准备去练几节课。</li></ol><h1 id="练车心得"><a href="#练车心得" class="headerlink" title="练车心得"></a>练车心得</h1><p>2019/6/10去驾校练车，由于平日练车的人不多所以直接一次性练了3节课（<code>3280*3</code>），练车后觉得还是挺有帮助的。</p><ol><li>上车前：从副驾侧绕到车头中间后退3步蹲下看车底和轮胎，然后从副驾侧绕道车尾后退3步蹲下看车底和轮胎 检查有没有小动物，儿童，或障碍物，有没有漏油，变形，车轮是否回正等。确认无误后，从后面绕到车右侧开门上车。。（不能从车头直接绕到驾驶室）</li><li>上车时：先看后方，无人时把车门开一个缝，然后再扭头观察后方。无车情况下打开车门进入驾驶室。坐下后关车门：关车门分两段，先虚掩一下车门，确认不会夹到东西，再用力关上，关上后顺便锁车门！不锁车门会扣分。然后向考官问好：こんにちは，留个好印象。</li><li>打火前准备：调节座椅位置，调节车内后视镜（就算合适也要调整，要有这个动作），系上安全带，并告诉考官 シートベルト(seat belt)お願いいたします。如果车轮没有回正的话，把车轮回正。依次摸一下档位和手刹，确认手刹已经拉上，档位在P档，雨刮，灯光拨杆位置都正确。确认的时候可以用手指一个一个点过去做确认状。然后踩着刹车，发动引擎，启动后确认车况和指示灯无异常。</li><li>打火后准备：调节左右2个后视镜，如果下雨情况下要打开雨刷。（没打火调不了左右后视镜）准备完之后告诉考官 準備終わりました。</li><li>当考官告诉你 出発，回答　はい。然后挂D档，松手刹，打右转灯。依次扭头确认后方，左后视镜，车内后视镜，右后视镜，右侧，扭头看右向方（记住一定要回头！不然会扣分！扣分！分！），没车的情况下松开刹车起步。</li><li>进入主道前要停车，依次观察车内后视镜，右方后视镜，右后方，无车情况下方可进入。</li><li>过弯道后进入直道要加速至35-40码，进入弯道前减速。</li></ol><hr><ol start="8"><li>此时考官会说 <code>3</code>番：右，到<code>33</code>号附近（提前30米）打右转灯。确认车内后视镜，右方后视镜，右后方。无车开始向右并线，到<code>3号</code>再次3点确认后右转到左道上，然后此直道上要加速到35-40码。</li><li>此时考官会说 <code>35</code>番：右，打右转灯，右方3点确认。可在上一步的基础上贴近右侧线，到<code>35号</code>前再次右方3次确认进入<code>直接弯</code>。</li><li>此时考官会说 <code>38</code>番：右，打右转灯，在路口停车以此确认左后视镜，车内后视镜，右后视镜，右方，然后看着左方没车的时候拐入左侧道路。</li><li>此时考官会说 <code>2</code>番：左，此时离2号还隔着一个<code>红绿灯</code>，不要急着打灯。正常通过红绿灯后，打左转灯。然后依次左方3点确认后开始向左并线。在2号时停车看右方，右后视镜，车内后视镜，左边后视镜，左前方，然后看下右方没车转向左道。</li><li>此时考官会说 <code>1</code>番：左，打左转打。左方3点确认，没车的话往左并线。到了<code>1号</code>后停车左方3点确认没车的话进入左道，前方直接要加速到35-40码。前方十字路口<code>有树（見通し悪い場所）</code>，要降速至10码以下到达路口时要前倾以右左右的顺序确认缓慢通过。</li><li>此时考官会说 <code>50</code>番：左，打左转灯，左方3点确认，向左并线。到达50号时再次左方3点确认，没车时开始进入<code>S弯</code>。</li><li>此时考官会说 <code>49</code>番：右，在路口时要停车看右前方，车内后视镜，左前方，没车时右转到左道。</li><li>此时考官会说 <code>16</code>番：左，打左转灯，左方3点确认，并线至左边。然后到达<code>16</code>号时<code>停车3秒(止まれ)</code>,不停会挂掉。看右前，车内后视镜，左侧后视镜，扭头看后方。然后看下右方没车的话开始左转。前方有一个路口，减速通过。然后有一个人行道，减速通过。</li><li>此时考官会说 <code>14</code>番：左，打左转灯。左方3点确认，开始向左并线。到达<code>14</code>号再次3点确认，没车时开始左转。前人有一个红绿灯，注意看灯。通过后加速到35-40码。</li><li>此时考官会说 <code>4</code>番：右，打右转打，右方3点确认，并线到右边。到达4号后再次右方3点确认，看下左边没车的话开始进入左道。</li><li>此时考官会说 <code>8</code>番：右，打右转打，右方3点确认，向右侧并线。同样也要反复左右偏头确认后再进入左侧道路。前方<code>有树（見通し悪い場所）</code>，要路口前要减速到10码以下，以右左右的顺序确认缓慢通过。</li><li>此时考官会说 <code>10</code>番：右，打右转灯，右方3点确认，然后向右侧并线。到达10号再次右方3点确认，并进入左道。此时加速至40-50， 前方有<code>障碍物</code>，还有50米左右时打右转灯，然后右方3点确认，打30度方向盘加速进入右道，车子摆正后打左转灯，到达障碍物时左方3点确认，没车时打30度方向盘并入左侧。前方过弯道后打左转灯，左方3点确认。没车时进入左道。</li><li>此时考官会说 <code>左</code> 终点停車,减速，打左灯，回头看，贴边，在指定的位置慢慢停住。（左侧30CM以内，左前方铁栏杆50CM以内）。</li></ol><hr><ol start="22"><li>先拉手刹（不用按），然后挂P档。如果雨刷打开着的话要向前推关掉雨刷，熄火。把座椅推到最后，然后解掉安全带。把车门打开一个缝，观察后方安全推开车门，一只脚踏出去后告诉考官 終わりました。</li><li>从车的后方绕到考官的左侧车窗，听候发落。。</li><li>车开到终点，考官会根据你的表现告诉你及不及格，合格的话归还号码牌，不合格的话会还你申请资料。有时候考官会问你两句，比如说你之前练了多久的车，在哪个驾校练的，这是第几次考试了之类的，有时候结果介于及格和不及格之间的话，回答没怎么练过，或者驾校的名声比较臭的话容易给不及格。不及格的话一般考官会告诉你扣分点在哪里，你是怎么错的，不过一般也就说一两个地方，如果错的比较多的话考官不会全部都告诉你，但是如果教官完全没说的话你可以开口问，考官是有义务告知你的，问的话不会不说。等说完之后就按照指示去约下一次的考试。及格的话，去换证窗口办手续，按照指示等两三个小时，就可以领到驾照了。最后祝换证的朋友们都能一切顺利！</li></ol><h1 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li>打方向盘不要太急，不稳会扣分。</li><li>打方向盘一次不要太多，回盘一次扣5分。</li><li>止まれ 不停车会被直接踩停挂掉考试;红灯不停会被踩停挂掉考试;逆行会被踩停挂掉考试。</li><li>考试前拿着路线图实地进场走一走，再熟悉一遍(11:45~12:45)。</li><li>要先打灯后确认，到达目的地点后再次确认方可动盘。</li><li>确认的时候要保持方向盘水平且不能动盘。</li><li>有树的地方（見通し悪い場所）一定要减速并左右观察确定。</li><li>路线一定要熟记，在哪往哪转提前心里要有谱。</li></ol><h1 id="友情提示"><a href="#友情提示" class="headerlink" title="友情提示"></a>友情提示</h1><ol><li>日本驾照的扣分是：每个月有3分。各种违章，按轻重扣分不同。比如15号，你的3分扣完了，那么你这个月就不能再开车了。但下个月自动还是有3分的。</li><li>开车的时候，一定不要喝酒，一口都不行，因为你考回来的驾照会被吊销！另外，安全带，上车后必须系上！必须！包括副驾驶的！如果副驾驶没有系安全带，警察看到后，司机的驾照仍旧会被扣分。</li><li>普通道路的时候，可以稍微超速，80km/h的限速，开到120km/h的也大有人在，只是有被扣分罚钱的危险。</li></ol><h1 id="最后配一张琦玉考试的平面路线图"><a href="#最后配一张琦玉考试的平面路线图" class="headerlink" title="最后配一张琦玉考试的平面路线图"></a>最后配一张琦玉考试的平面路线图</h1><p><img src="/img/blog/saitama.png" alt></p><h1 id="更加真实一点的地图"><a href="#更加真实一点的地图" class="headerlink" title="更加真实一点的地图"></a>更加真实一点的地图</h1><p><img src="/img/blog/course.jpg" alt></p><h1 id="2019-08-20-更新"><a href="#2019-08-20-更新" class="headerlink" title="2019/08/20 更新"></a>2019/08/20 更新</h1><p>在昨天，终于拿到了驾照，不负这段付出的时光，希望每个努力的人都有一个好结果。<br><img src="/img/blog/menkyo.jpg" alt></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://www.infukuoka.info/life/5168.html" target="_blank" rel="noopener">中国驾照转日本驾照超详细攻略！</a></li><li><a href="https://blog.xiangzhuyuan.com/tranfer-chinese-driver-license-to-japanese/" target="_blank" rel="noopener">东京换驾照记</a></li><li><a href="https://baijiahao.baidu.com/s?id=1595714456461270665&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">日本留学 ｜ 如何在日本换驾照</a></li><li><a href="http://mini.eastday.com/bdmip/180404112201086.html#" target="_blank" rel="noopener">YMG教你中国驾照如何换日本驾照</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然没有100%确定要在日本定居，但是也不能像咸鱼一样度日。而且日本的驾照可以作为身份证明使用（有些日企在填资料时有一项是填：是否有驾照），所以便有准备考驾照，当然以后自驾游啥的也是很方便。在准备考试的过程中经过多方了解和调查获取了许多相关知识，所以准备以blog的形式记录下来。一是把内容整理出来方便自己更好的通过考试，也可以方便在日本想要换驾照的朋友提供个参照。（本篇文章历时2周，花费时间5个小时左右）&lt;br&gt;
    
    </summary>
    
      <category term="japan" scheme="https://blog.xiaomo.info/categories/japan/"/>
    
    
      <category term="生活" scheme="https://blog.xiaomo.info/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>2018年终总结（日本的生活日常）</title>
    <link href="https://blog.xiaomo.info/2018/nihonnkita2kagetsu/"/>
    <id>https://blog.xiaomo.info/2018/nihonnkita2kagetsu/</id>
    <published>2018-12-31T00:00:00.000Z</published>
    <updated>2020-06-28T16:53:07.143Z</updated>
    
    <content type="html"><![CDATA[<p>来日本也差不多有2个月啦，这2个月时间也一直没有更新博客,本来是在元旦就应该开始写的，但是一直拖到了现在。主要是因为换了新环境很多事情需要做，很多地方需要适应，所以没时间也没法静下心来写写博客记录一下生活。现在终于有时间坐下来记录一下在日本的生活日常。<br><a id="more"></a></p><h1 id="我为什么要来日本"><a href="#我为什么要来日本" class="headerlink" title="我为什么要来日本"></a>我为什么要来日本</h1><p>大学的时候一直对动漫特别感觉趣，毕业后在杭州偶然接触到对日的软件开发，开始萌发了学日语的想法。后来看动漫的量越来越多，听力也慢慢好起来，开始有了到日本看一看的念头，但是因为能力受限一直没有到日本，但是在2015年~2018年期间有断断续续的背日语单词。17年国庆节的时候和老婆一起来日本自由行12天，亲眼见证了日本的自然和人文，便把到日本工作作为自己的下一个计划。大家应该都知道2018年是互联网很不好的一年，裁员风暴一波又一波，但是我的前公司并没有因此裁员反而吸收了大量被裁员的人。我15年进那家公司的时候不到60人，我18年离职的时候己经快1000人了，我亲眼见证了这家公司的飞速成长。但是为我什么离职呢，我在这家公司3年了也想换换新的环境，但是国内的环境不好自己带的那个项目表现不是很好又经常通宵加班所以趁此机会开始找日本的工作机会。从6月份开始通过猎头远程面试到7月份确定工作，然后就是各种证件EMS给公司办在留资格证。</p><h1 id="我来日本多久了"><a href="#我来日本多久了" class="headerlink" title="我来日本多久了"></a>我来日本多久了</h1><p>2018年8月份开始申请在留，2019年11月拿到手，但是很快到日本的新年了。所以我在农历的腊月中旬（2019.1.16）来到日本东京，2019年在日本度过了的第一个中国新年，正好今年东京塔在春节当晚亮起了中国红，刷爆了朋友圈,突然也有了一点恋家的感觉。我老家在非常偏僻的农村，后来了为读书我们搬到了镇上。考上了县城高中然后在县城买了房子。到后来读大学，去了武汉。毕业后和朋友一起到杭州谋生。现在都各自成家立业，朋友正在注册着属于自己的公司，而我飘扬过海来到日本工作。我一直不信星座，但是作为射手座的我，星座解释说射手座向往自由和远方，这一点我倒是深信不疑,从一个小村庄到出国，是射手座给我的勇气。截至到目前为止，我在日本待了大概有2个月，可能还会待很多个两个月。今年天皇退位,所以黄金周放10天假可以回杭州休息一段时间了。</p><h1 id="在日本住的房子是什么样的"><a href="#在日本住的房子是什么样的" class="headerlink" title="在日本住的房子是什么样的"></a>在日本住的房子是什么样的</h1><p>公司提供了3种方案：1、住公司宿舍——价格最便宜，也最省心，但是环境不是很好，地方也比较小。 2、在公司合租的中介那边自租房间——个人感觉价格比较贵，而且有朋友在日本工作，问我愿不愿意合租。 3、自理——我选择了自己搞定，在日本和朋友合租了UR团地，9万一个月，总面积54平，3DK。在房子上没有走很多才来日本的朋友的坑，这一点比较省心。但是由于住的地方比较远，所以上班时间得花1个多小时。不过和北上广比较来，也差不了太多。既然选择在大城市，就得有这个觉悟。</p><h1 id="在日本做什么样的工作"><a href="#在日本做什么样的工作" class="headerlink" title="在日本做什么样的工作"></a>在日本做什么样的工作</h1><p>我是2019年1月17号到达日本，来了之后公司催着去上班（我还以为是2.1号开始）。所以在17号当天急急忙忙办了各种手续。包括住民登记、办手机卡、办银行卡、去公司签协议等等。于是，在2019年2月18号，我正式开始了在日本的第一天社畜生活。我是在 在日华人在日本开的公司，属于派遣形式。第一个现场是在浦田，公司名字是日立制作所，我对日立印象最深的就是中国很多电梯都是三菱和日立的品牌。做的工作内容并没有什么技术性，短暂的做了一些测试的工作，在这期间我开始疯狂的记单词，没有工作任务的时候就记。好在这个现场的工作时间不长，2019年2月底就结束了，所以我开始面试新的项目，从3.1号开始到下个现场上班。说实话，因为自己日语口语太差，加上基本上没有对日开发经验，所以一度非常受挫。第一个面试的项目是在SoftBank，第二个是日本NSD,第三个是ricoh(理光)。第三个面上了，我特意去了解了一下是个世界500强的公司，还算是不错。工作内容是使用Angular6做网站开发，因为我经常不务正业研究一些乱七八糟的技术，包括但不限于Angular,React之类。在面试的时候虽然口语表达的不好，但是把自己Angular会的部分展示出来成功的获得了工作机会。还有最后2天就要开始做这个项目了，希望会是一个开心的过程。</p><h1 id="在日本的通讯方式"><a href="#在日本的通讯方式" class="headerlink" title="在日本的通讯方式"></a>在日本的通讯方式</h1><p>来日本的第一天匆匆忙忙办了一张Y！Mobile的手机卡，一个月2000日元，3GB流量。由于考虑手机用的比较久，电池不耐用，32G内存也不够用等等花了8万日元入手了一台256G的iphoneXR，办了一个SoftBank的卡，因为室友也用的SoftBank的卡，所以每个月还可以额外优惠1000日元。</p><h1 id="在日本吃什么"><a href="#在日本吃什么" class="headerlink" title="在日本吃什么"></a>在日本吃什么</h1><p>首先，我出生在内陆，很少吃海鲜，偶尔吃虾和鱼。来了日本之后看到鱼特别便宜但是却没有想吃的欲望觉得还是挺浪费的。正所谓入乡随俗，所以我也开始尝试一些日本料理，但是吃了一次生鱼片我确实还没法习惯。再加上店里吃饭比较贵，我一般都是自己做饭吃，带便当去现场中午吃。住的地方超市、便利店、物产店都很方便，想吃什么基本上都能买到。</p><h1 id="打算在日本待多久"><a href="#打算在日本待多久" class="headerlink" title="打算在日本待多久"></a>打算在日本待多久</h1><p>目前来说还没有确定，只能说走一步看一步。刚来日本各种东西不熟悉、语言不通、环境不适应等等各种因素我也打过退堂鼓，但是觉得自己努力了这么久才来了不到2个月，还得需要更多的时间去适应。</p><h1 id="日本的工作加班吗"><a href="#日本的工作加班吗" class="headerlink" title="日本的工作加班吗"></a>日本的工作加班吗</h1><p>做IT行业我说不加班你会信吗？ 你肯定会说：我信你鬼哟，你个糟老头子坏的很！ 确实，IT行业不需要和人打交道，有内容一直都可以做。但是日本确定很少加班，日本和中国不一样，日本是按照出勤时间算。比如说一天上班8小时，一个月上20天。所以日本普遍月出勤时间在150-160之间。到了下班时间还在公司墨迹领导会催着回去，而且有些公司规定周三、周五强制6点离场。在现在这个现场我偶尔也有加班，但是最晚是到8点钟，这样的话我出勤时间就有10个小时。我之后如果有事情要办，可以调休去办自己的事情，只要总工时达到了规定时间就能发全工资，所以我觉得这一点还是比较人性化。</p><h1 id="日本的社保"><a href="#日本的社保" class="headerlink" title="日本的社保"></a>日本的社保</h1><p>日本有社保和厚生年金，年金和国内的一金非常类似，自己的公司各负担一半。社保可以不交，但是国民健康保险最好交一下，我现在每个月是2700日元。日本纳税是按照上一年度纳税，我第一年来日本所以比较低，明年的话可能一个月要交8000左右的保险金。这个国民健康保险看病自己只用负担30%，家人也可以用，小孩子是全免费的。有些不分大人小孩可吃的药医生出会多开一些剂量，不用出钱大人也可以用，比如说日本人春天物别容易犯的花粉症的抗过敏药。我到现在为止拿到了国民健康保险卡，这个月也刚交了2700的保险金，但是没有到医院去过，所以具体什么样子得等以后再实践。</p><h1 id="日本IT行业的那些规矩"><a href="#日本IT行业的那些规矩" class="headerlink" title="日本IT行业的那些规矩"></a>日本IT行业的那些规矩</h1><p>在日本做IT没有灵活可言，要用什么工具，什么版本基本上都是定好的，给什么用什么。有问题一定要及时和上级沟通，上级会很认真的帮忙解决，自己想当然做到最后出问题会很严重，一直出错最终会失去领导的信任。在工位上可以玩手机，可以充电啥的，但是绝对不要把USB插到电脑上，也不要在办公室拍照。日本人上班工作喝水基本上都是在自动贩卖机上买各种饮料或矿泉水，目前只有我一个人会抱着个大大的保温杯去接开水喝，而且日本人食量很小，我每天中午都吃的是我们领导的2倍多，才开始还觉得有点羞耻，后来脸厚了也就无畏无惧了。我现在工作的地方允许在工位上吃饭，可能有些地方会不让。</p><h1 id="在日本的中国人可信吗"><a href="#在日本的中国人可信吗" class="headerlink" title="在日本的中国人可信吗"></a>在日本的中国人可信吗</h1><p>来日本之前看过很多文章说中国人坑中国人，首先我觉得比较丢脸，因为我也是中国人，但是我觉得事实上并没有说的那么严重。至少我来日本遇到的中国人都还是挺好的，包括我现在公司的社长、公司营业、办手机卡的中国营业员、项目组的中国人，感觉都还挺好的。目前没有出现被坑的情况，也希望以后不要遇到，不要让我也觉得国人坑国人是那么普遍。</p><h1 id="日本的卫生间"><a href="#日本的卫生间" class="headerlink" title="日本的卫生间"></a>日本的卫生间</h1><p>可能有朋友有觉得我把这个单独提出来是不是有点变态，其实我觉得是有些可以拿出来说的。首先，日本的卫生间干净的让人觉得十分舒服，完全没有味道。每个水龙头都有热水，旁边摆的洗手液永远都不会成空瓶子。有风干机，有镜子，每个马桶边上的纸从来不会空。总之，这些小细节真的是让人非常喜欢。</p><h1 id="办公室工作结构"><a href="#办公室工作结构" class="headerlink" title="办公室工作结构"></a>办公室工作结构</h1><p>我目前所在的项目是6个人，4个中国人和2个日本人。为了练日语，我会经常厚脸皮的和其中一个日本人发消息聊天，在没有工作内容的时候经常会一聊 聊半天时间。从开始打字都不知道打什么，到现在能长篇大论，从吃的谈到用的，从家庭谈到工作。我觉得我进步还是挺大的，但是目标最弱的还是口语，所以在接下来的时候我会努力的去读去练发声。</p><h1 id="非工作时间我一般在做什么"><a href="#非工作时间我一般在做什么" class="headerlink" title="非工作时间我一般在做什么"></a>非工作时间我一般在做什么</h1><p>来日本一个多月了，除了上班我感觉别的事情我真的什么都没做，但是总觉得时间一晃就非常晚了。一般来说，花1个多小时回家，再花1个小时做饭吃饭，再玩玩电脑玩玩手机不知不觉都己经过了12点。从高中开始一直对钢琴比较有兴趣，所以买了雅马哈的电钢琴但是也没什么时间练，但是它也是我以后其中计划的一环，总有一天我会流利的弹出我喜欢的钢琴曲。周六固定在日本政府办的免费日语教室上课，然后和朋友一起吃个晚饭。周末做家里蹲一睡一整天，其实我觉得这样很不好，这个我会尽量改掉。我一直计划想去海边去玩，但是因为温度比较低一直没有去，等天气暖和一点了去海边玩。在国内的时候玩着来日本了一有时间我就要出去各种浪，但是真正来了日本快2个月了一直没有出去玩过真是汗颜。</p><h1 id="日本的电车"><a href="#日本的电车" class="headerlink" title="日本的电车"></a>日本的电车</h1><p>日本的电车非常准时，我仔细注意过，我只要早上固定在某个时间点从家里出来，一定是在某个时间点到达公司。只有一次电车延迟了半个多小时，原因好像是我坐的这条线正好遇到了人身事故。日本的电车非常安静，日本人在电车上很喜欢看书。电车上明文规定手机保持震动，不要在车上打电话，所以车上非常安静。能听到别人说的悄悄话和翻书的声音。电车上有2个固定的显示屏，一个放广告一个放实时站点信息。不想看广告的话完全不会被打扰，屏幕上会有当天的天气预报。每个电车基本上都设置有3节女性车厢，早晚高峰最好不要坐，不然有可能会被白眼，其实这倒没什么，万一遇到蛮不讲理的女性非要说是痴汉会很伤脑筋。东京早晚高峰电车非常拥挤，这也是为什么男性要尽量避免女性专用车厢。但是平时的话很容易遇到座位，因为有很多日本人都不坐。据说是他们觉得会有比自己更需要座位的人，所以不是特别累就会站着，反正我是奉行有位置不坐是王八的バカ。</p><h1 id="日本的电梯文化"><a href="#日本的电梯文化" class="headerlink" title="日本的电梯文化"></a>日本的电梯文化</h1><p>我工作的现场有8个电梯，在两边都排着整齐的队伍。有电梯下来依次乘坐，坐不下的会退回来等下一部电梯。站的太满的时候靠近门的那部分人会先出来等别人都出来了再上去，电梯按钮边上的人也会帮忙一直把开的按钮一直按着，不会像国内站在里面想出来只能使劲挤出来。在坐电梯的时候如果门快关了有快速跑过来按开电梯，进来之前会先鞠躬道歉再过来。在按钮边上站着的人会按着开的按钮等所有人都出来了他们再出来，因为我没有这个习惯所以一到目的地楼层我就会先出来，所以心里会有点抱歉。</p><h1 id="来日本2个月的感觉"><a href="#来日本2个月的感觉" class="headerlink" title="来日本2个月的感觉"></a>来日本2个月的感觉</h1><p>首先从去市役所做住所登录来说，政府人员真的是非常非常有耐心。我听不懂他们说什么的时候，会用非常慢的语速再重复，如果再听不懂会用笔写下来。还是不懂的话我会打电话给日语好的朋友让我朋友帮我说，不管花多长时间他们不会显示出不耐烦。据日本的朋友说，我们作为纳税人养活着他们，他们态度好不是理所当然的么。我觉得非常震惊，但是仔细想过又觉得他说的非常有道理。但是日本非常不方便的是办事情只能工作日，周六周日从来不上班。但是工作现场可以调休这一点也正好弥补了这一点不方便。还有非常不方便的地方就是日本的快递不能邮寄到公司，只能邮到家里。但是提前不能指定时间，他们送到之后。人不在家拿不了时，会给一张不在联络票放在邮箱，拿到不在联络票再指定时间。我觉得这真是一个神奇而又变态的设定。在日本总体来说有着非常好的服务态度，不用担心食品安全问题，每天都能看到蓝天，很多细节感人泪人，也不用在意各种墙，写代码因为网络原因出现各种奇怪而又难解决的问题。但是毕竟这不是自己的家乡，会觉得不适应。也会想家人，想老婆，想孩子，也想我家那只蓝猫。</p><h1 id="我接下来的计划"><a href="#我接下来的计划" class="headerlink" title="我接下来的计划"></a>我接下来的计划</h1><p>在日本工作生活，时间越长越觉得日语不好是多么的不方便。听着别人说一口流利的日语，真的是不要太羡慕。所以接下来首要的任务就是加油学日语，然后报今年7月份的N2。如果N2能考，12月份接着考N1,万一考不过继续考N2。反正不考到N1不罢休。然后就是好好学学技术，技术是自己的饭碗所以这个当然不能丢。计划做一个独立小游戏上线推广。朋友注册了公司，帮忙做一些公司建设方面的内容。N1到手之后开始把时间转移到学英语和钢琴上，然后考一些日本政府认可的技术证书等等（高级人才签证的准备工作）。我一直觉得人活着，过一天就要有新的收获，所以每一天都在不停的学习。达到一个目标后，继续开始新的目标。比如说初中时各个假期学五笔、学PS、学装系统、电脑维修等等，这些都为我以后的工作生活带来了极大的方便 。有的时候和我朋友讲我的经历，他们总会觉得我的经历充满了传奇，非常的羡慕。但是我想说的是，每个人都是一个精彩的传奇，我被别人羡慕着同样也羡慕着别人。我也有特别多让人烦心的事情，也是一个普通的不能再普通的普通人。</p><h1 id="不会日语可以来日本工作吗"><a href="#不会日语可以来日本工作吗" class="headerlink" title="不会日语可以来日本工作吗"></a>不会日语可以来日本工作吗</h1><p>完全可以，因为众所周知，日本是一个少子化相当严重的国家，而IT行业缺人尤为严重。只要会一点点技术，基本上都不会找不到工作。不过工资不会太高，一般会在25万左右。但是想在日本长期生活，建议尽最大努力提长自己的日语能力。哪怕来了日语才开始记50音图都没关系，但是一直要快点把日语学好，因为这关系到自己的待遇和生活质量。谁都不想出去了只买自己知道的东西，找不到东西不知道怎么给店员说。有人可能会反驳，很多店都有中国店员，甚至有很多日本人也在在学中文。但是在日本这个国家生活，只想靠中文生活是不是有点说不过去。</p><h1 id="以上"><a href="#以上" class="headerlink" title="以上"></a>以上</h1><p>断断续续天马行空的写了些乱七八糟的东西。想看的朋友将就着看，如果有什么问题想了解我没有提到的欢迎留言，我会适当补充内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来日本也差不多有2个月啦，这2个月时间也一直没有更新博客,本来是在元旦就应该开始写的，但是一直拖到了现在。主要是因为换了新环境很多事情需要做，很多地方需要适应，所以没时间也没法静下心来写写博客记录一下生活。现在终于有时间坐下来记录一下在日本的生活日常。&lt;br&gt;
    
    </summary>
    
      <category term="japan" scheme="https://blog.xiaomo.info/categories/japan/"/>
    
    
      <category term="生活" scheme="https://blog.xiaomo.info/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Fps游戏常用功能</title>
    <link href="https://blog.xiaomo.info/2018/unityFpsCommonMethod/"/>
    <id>https://blog.xiaomo.info/2018/unityFpsCommonMethod/</id>
    <published>2018-12-07T00:00:00.000Z</published>
    <updated>2020-06-28T16:53:07.143Z</updated>
    
    <content type="html"><![CDATA[<p>镜头拉远拉近，类似狙的镜头缩放；枪口特效；角色的移动和镜头旋转<br><a id="more"></a></p><h1 id="镜头拉远拉近"><a href="#镜头拉远拉近" class="headerlink" title="镜头拉远拉近"></a>镜头拉远拉近</h1><ol><li>在main camera中添加一个脚本 <code>CameraZoom</code></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CameraZoom</span> :</span> MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Camera mainCamera;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] zoomLevel = &#123;<span class="number">60</span>, <span class="number">40</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentLevel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mainCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            currentLevel += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (currentLevel &gt;= zoomLevel.Length)</span><br><span class="line">            &#123;</span><br><span class="line">                currentLevel = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> currentFieldOfView = zoomLevel[currentLevel];</span><br><span class="line"></span><br><span class="line">        mainCamera.fieldOfView = Mathf.Lerp(mainCamera.fieldOfView, currentFieldOfView, <span class="number">0.1f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>此脚本的功能是可以在编辑器中自定义缩放等级，不设置的话默认是60,40,20共3个等级。当按下鼠标左键的时候缩放等级+1,到了最大缩放等级回到0</li></ol><h1 id="fps角色组成部分"><a href="#fps角色组成部分" class="headerlink" title="fps角色组成部分"></a>fps角色组成部分</h1><p><img src="https://image.xiaomo.info/unity3d/fps/player.png" alt></p><ul><li>player是个空物体，是放角色模型的容器</li><li>player/main camera是player的子物体，我们控制player移动时camera跟着一起移动</li><li>player/guns 是枪的容器,放所有的枪</li><li>player/guns/HandGun是手枪的容器，里面放手枪的模型，枪口</li><li>player/guns/handGun/firePoint/fireEffect 是枪口开火特效，默认隐藏，开火时显示</li></ul><ol><li>新建一个脚本<code>FireEffectController</code>挂在<code>firePoint</code>空物体上,当点击鼠标左键时开火显示特效，使用<code>Invoke</code>方法延迟0.3秒隐藏</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GunFireEffect</span> :</span> MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GameObject fireEffect;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        fireEffect = transform.Find(<span class="string">"Effect"</span>).gameObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            fireEffect.SetActive(<span class="literal">true</span>);</span><br><span class="line">            Invoke(<span class="string">"HideEffect"</span>, <span class="number">0.3f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HideEffect</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        fireEffect.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="角色控制"><a href="#角色控制" class="headerlink" title="角色控制"></a>角色控制</h1><ol><li>移动,这个方法因为乘了<code>Time.deltaTime</code>，所以它是在<code>Update</code>方法中调用的，h或者v要有其一大于0</li></ol><figure class="highlight plain"><figcaption><span><summary></summary></span></figcaption><table><tr><td class="code"><pre><span class="line">/// 在update中调用</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;h&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;v&quot;&gt;&lt;/param&gt;</span><br><span class="line">public void Move(float h, float v)</span><br><span class="line">&#123;</span><br><span class="line">    Vector3 dir = new Vector3(h * speed * Time.deltaTime, 0, v * speed * Time.deltaTime);</span><br><span class="line">    player.Translate(dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>旋转视野，这个方法只能在<code>FixedUpdate中调用</code>，如果要放在<code>Update</code>中,x、y要乘于<code>Time.deltaTime</code></li></ol><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 在fixUpdate中调用</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="x"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="y"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RotateView</span>(<span class="params"><span class="keyword">float</span> x, <span class="keyword">float</span> y</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x *= rotateSpeed;</span><br><span class="line">    y *= rotateSpeed;</span><br><span class="line">    <span class="comment">// 左右沿自身旋转</span></span><br><span class="line">    transform.Rotate(-y, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下旋转沿世界坐标</span></span><br><span class="line">    transform.Rotate(<span class="number">0</span>, x, <span class="number">0</span>, Space.World);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>角色控制器脚本<code>FpsPlayerController</code>方法</li></ol><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FpsPlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Range(2, 4)</span>] <span class="keyword">public</span> <span class="keyword">int</span> speed = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Transform player;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> rotateSpeed = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        player = GameObject.Find(<span class="string">"Player"</span>).transform;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 键盘</span></span><br><span class="line">        <span class="keyword">float</span> h = Input.GetAxisRaw(<span class="string">"Horizontal"</span>);</span><br><span class="line">        <span class="keyword">float</span> v = Input.GetAxisRaw(<span class="string">"Vertical"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h &gt;= <span class="number">0.1f</span> || v &gt;= <span class="number">0.1f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Move(h, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 鼠标</span></span><br><span class="line">        <span class="keyword">float</span> x = Input.GetAxisRaw(<span class="string">"Mouse X"</span>);</span><br><span class="line">        <span class="keyword">float</span> y = Input.GetAxisRaw(<span class="string">"Mouse Y"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0.1f</span> || y &gt; <span class="number">0.1f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RotateView(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="https://image.xiaomo.info/unity3d/camera/fps.gif" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;镜头拉远拉近，类似狙的镜头缩放；枪口特效；角色的移动和镜头旋转&lt;br&gt;
    
    </summary>
    
      <category term="game" scheme="https://blog.xiaomo.info/categories/game/"/>
    
    
      <category term="function" scheme="https://blog.xiaomo.info/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>镜头拉远拉近</title>
    <link href="https://blog.xiaomo.info/2018/unitySceneFarAndNear/"/>
    <id>https://blog.xiaomo.info/2018/unitySceneFarAndNear/</id>
    <published>2018-12-07T00:00:00.000Z</published>
    <updated>2020-06-28T16:53:07.143Z</updated>
    
    <content type="html"><![CDATA[<p>镜头拉远拉近，类似狙的镜头缩放<br><a id="more"></a></p><ol><li>在场景中创建一个cube,默认fieldOfView为60</li><li>在main camera中添加一个脚本 <code>CameraZoom</code></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CameraZoom</span> :</span> MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Camera mainCamera;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] zoomLevel = &#123;<span class="number">60</span>, <span class="number">40</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentLevel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mainCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            currentLevel += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (currentLevel &gt;= zoomLevel.Length)</span><br><span class="line">            &#123;</span><br><span class="line">                currentLevel = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> currentFieldOfView = zoomLevel[currentLevel];</span><br><span class="line"></span><br><span class="line">        mainCamera.fieldOfView = Mathf.Lerp(mainCamera.fieldOfView, currentFieldOfView, <span class="number">0.1f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>此脚本的功能是可以在编辑器中自定义缩放等级，不设置的话默认是60,40,20共3个等级。当按下鼠标左键的时候缩放等级+1,到了最大缩放等级回到0</li><li>效果如下<br><img src="https://image.xiaomo.info/unity3d/camera/cameraFieldOfView.gif" alt></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;镜头拉远拉近，类似狙的镜头缩放&lt;br&gt;
    
    </summary>
    
      <category term="game" scheme="https://blog.xiaomo.info/categories/game/"/>
    
    
      <category term="function" scheme="https://blog.xiaomo.info/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>unity3d小地图</title>
    <link href="https://blog.xiaomo.info/2018/unity3dMiniMap/"/>
    <id>https://blog.xiaomo.info/2018/unity3dMiniMap/</id>
    <published>2018-11-20T00:00:00.000Z</published>
    <updated>2020-06-28T16:53:07.143Z</updated>
    
    <content type="html"><![CDATA[<p>小地图基本是每个RPG游戏都必备的功能，如果连这个都不会做就太不应该了。<br><a id="more"></a></p><ol><li>新建一个相机，<code>projection</code>设置为正交模式（2d）<code>orthographic</code>,size大概为30左右（视地图而定）,把它放在角色的容器中,让它可以和角色一起移动。Rotation绕x旋转90度，放到天上调整到合适位置和距离<br><img src="https://image.xiaomo.info/unity3d/miniMap/miniMapCamera.png" alt></li><li>新建一个renderTexture,把它给小地图相机</li><li>下载<a href="https://image.xiaomo.info/unity3d3d/ugui/minimap/Minimap.unity3dpackage" target="_blank" rel="noopener">miniMap包</a>导入，新建材质球。shade设置为custom，第一个指定为renderTexture,第二个指定为mask<br><img src="https://image.xiaomo.info/unity3d/miniMap/miniMapPackage.png" alt><br><img src="https://image.xiaomo.info/unity3d/miniMap/mat_miniMap.png" alt></li><li>新建一个RawImage,把renderTexture和材质球给它<br><img src="https://image.xiaomo.info/unity3d/miniMap/miniMapImage.png" alt></li><li>在角色容器中添加一个plane，把miniMap包中的icon给它。然后把layer设置为miniMap层。</li><li>把角色模型本体设置为Player层，把主相机的culling mask 取消miniMap,小地图摄像机的culling mask取消player层<br><img src="https://image.xiaomo.info/unity3d/miniMap/mainCamera.png" alt><br><img src="https://image.xiaomo.info/unity3d/miniMap/miniMapCameraCullingMask.png" alt></li><li>完成品如下，如果有外框可以给地图加个外框会漂亮一点<br><img src="https://image.xiaomo.info/unity3d/miniMap/CompleteMiniMap.png" alt></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小地图基本是每个RPG游戏都必备的功能，如果连这个都不会做就太不应该了。&lt;br&gt;
    
    </summary>
    
      <category term="game" scheme="https://blog.xiaomo.info/categories/game/"/>
    
    
      <category term="ugui" scheme="https://blog.xiaomo.info/tags/ugui/"/>
    
  </entry>
  
  <entry>
    <title>使用UGUI中的层级问题——以背包为例</title>
    <link href="https://blog.xiaomo.info/2018/UGUISorting/"/>
    <id>https://blog.xiaomo.info/2018/UGUISorting/</id>
    <published>2018-11-18T00:00:00.000Z</published>
    <updated>2020-06-28T16:53:07.143Z</updated>
    
    <content type="html"><![CDATA[<p>UGUI的canvas默认层级是UI，Sorting order 是0，由于unity渲染物体时是从上到下直接渲染的，这就导致了渲染出来的效果和我们预期的不一致，因此必须设置层级，指定渲染的先后顺序（层级低的先渲染）才行。<br><a id="more"></a></p><p>想要实现的效果是有一个背包，背包里有道具，鼠标移上去之后出现一个框显示物品的详细信息，移开就消失。但是默认UI层级会把挡住<br><img src="https://image.xiaomo.info/unity3d/ugui/bag/mask.png" alt></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol><li>在被挡住的UI上添加组件<code>canvas</code>,增大它的<code>sorting order</code>，但是坑爹的是：设置完后，层级的问题解决了，但是UI的所有事件被拦截（包括按钮的点击、UI拖拽等等）</li><li>给UI再设置一个组件Graphic RayCaster，完美解决，既可以显示特效，还不会遮挡UI。<br><img src="https://image.xiaomo.info/unity3d/ugui/bag/correct.png" alt></li><li>至此有个问题，如果界面很多都需要设置上述的canvas，那就需要自己实现一个管理类，给每个ui设置它的order，不过canvas会影响合并批次，所以不能有太多，自己权衡。</li><li>给Item上挂一个脚本，实现<code>IPointerEnter</code>和<code>IPointerExit</code>接口，分别对应设置Active属性</li></ol><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UI</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BagItem</span> : <span class="title">MonoBehaviour</span>, <span class="title">IPointerEnterHandler</span>, <span class="title">IPointerExitHandler</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> GameObject desc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            desc = transform.Find(<span class="string">"Desc"</span>).gameObject;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerEnter</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            desc.SetActive(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerExit</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            desc.SetActive(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p><img src="https://image.xiaomo.info/unity3d/ugui/bag/bag.gif" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UGUI的canvas默认层级是UI，Sorting order 是0，由于unity渲染物体时是从上到下直接渲染的，这就导致了渲染出来的效果和我们预期的不一致，因此必须设置层级，指定渲染的先后顺序（层级低的先渲染）才行。&lt;br&gt;
    
    </summary>
    
      <category term="game" scheme="https://blog.xiaomo.info/categories/game/"/>
    
    
      <category term="ugui" scheme="https://blog.xiaomo.info/tags/ugui/"/>
    
  </entry>
  
  <entry>
    <title>使用UGUI制作滚动列表-选服列表</title>
    <link href="https://blog.xiaomo.info/2018/UGUIServerList/"/>
    <id>https://blog.xiaomo.info/2018/UGUIServerList/</id>
    <published>2018-11-17T00:00:00.000Z</published>
    <updated>2020-06-28T16:53:07.143Z</updated>
    
    <content type="html"><![CDATA[<p>UGUI必将千秋万代，一统江湖！（麻烦给UGUI加一下动画系统，谢谢）<br><a id="more"></a></p><p>想要实现的效果..ummmm，大概是以下这个样子，这是最终做好的样子，记录一下<br><img src="https://image.xiaomo.info/unity3d/ugui/serverList/serverList.gif" alt></p><ol><li>假设我现在的目录结构是这样子的，canvas下有一个Bg,bg下有一个RegionFrom用来放服务器列表。<br><img src="https://image.xiaomo.info/unity3d/ugui/serverList/fileTree1.png" alt></li><li>在Region下新建一个Image控件ServerList用来做内容呈现的容器，给它添加<code>mask组件</code>和<code>scroll rect组件</code>,把<code>mask</code>的 <code>show mask graphic</code>的勾去掉。<br><img src="https://image.xiaomo.info/unity3d/ugui/serverList/fileTree3.png" alt></li><li>在ServerList下新建一个空物体Content做来做滑动的区域，这个区域的宽度和ServerList一样大，高度设置大一点,添加上GridLayoutGoup组件自动布局，设置好大小和间距。<br><img src="https://image.xiaomo.info/unity3d/ugui/serverList/fileTree2.png" alt></li><li>在Content下添加服务器项目，项目会被自动布局。运行后即可获得gif效果所示。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UGUI必将千秋万代，一统江湖！（麻烦给UGUI加一下动画系统，谢谢）&lt;br&gt;
    
    </summary>
    
      <category term="game" scheme="https://blog.xiaomo.info/categories/game/"/>
    
    
      <category term="ugui" scheme="https://blog.xiaomo.info/tags/ugui/"/>
    
  </entry>
  
  <entry>
    <title>docker应用</title>
    <link href="https://blog.xiaomo.info/2018/aboutDockerUse/"/>
    <id>https://blog.xiaomo.info/2018/aboutDockerUse/</id>
    <published>2018-06-22T00:00:00.000Z</published>
    <updated>2020-06-28T16:53:07.143Z</updated>
    
    <content type="html"><![CDATA[<p>docker是一个简化部署的容器,使用docker不仅能够降低性能消耗，而且方便部署工作，在互联网企业中使用十分普遍。<br><a id="more"></a></p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ol><li>解决了运行环境不一致的问题。</li><li>docker隔离了运行环境，对同一台服务器上运行的其他应用不会产生任何影响。</li><li>docker可伸缩的部署服务减少了资源的浪费和运维的人工成本。</li></ol><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://www.docker.com/get-docker" target="_blank" rel="noopener">https://www.docker.com/get-docker</a></p><h1 id="网易镜像"><a href="#网易镜像" class="headerlink" title="网易镜像"></a>网易镜像</h1><p><a href="https://c.163yun.com/hub#/m/home/" target="_blank" rel="noopener">https://c.163yun.com/hub#/m/home/</a></p><h1 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h1><h2 id="center-os"><a href="#center-os" class="headerlink" title="center os"></a>center os</h2><p>Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。通过 uname -r 命令查看你当前的内核版本<br><code>uname -r</code></p><h3 id="yum安装docker"><a href="#yum安装docker" class="headerlink" title="yum安装docker"></a>yum安装docker</h3><p><code>yum -y install docker-io</code><br>运行docker<br><code>systemctl start docker</code><br>测试<br><code>docker run hello-world</code></p><h3 id="脚本安装docker"><a href="#脚本安装docker" class="headerlink" title="脚本安装docker"></a>脚本安装docker</h3><p>更新系统组件<br><code>sudo yum update</code><br>执行 Docker 安装脚本<br><code>curl -fsSL https://get.docker.com/ | sh</code><br>启动docker<br><code>sudo service docker start</code><br>验证 docker 是否安装成功并在容器中执行一个测试的镜像。<br><code>sudo docker run hello-world</code><br><code>docker ps</code></p><h3 id="docker镜像加速"><a href="#docker镜像加速" class="headerlink" title="docker镜像加速"></a>docker镜像加速</h3><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：<a href="http://hub-mirror.c.163.com。新版的" target="_blank" rel="noopener">http://hub-mirror.c.163.com。新版的</a> Docker 使用 /etc/docker/daemon.json（Linux） 或者 %programdata%\docker\config\daemon.json（Windows） 来配置 Daemon。<br>请在该配置文件中加入（没有该文件的话，请先建一个）：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [<span class="string">"http://hub-mirror.c.163.com"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mac-os"><a href="#mac-os" class="headerlink" title="mac os"></a>mac os</h2><p>一个命令搞定<br><code>brew cask install docker</code></p><h3 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h3><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：<a href="http://hub-mirror.c.163.com。" target="_blank" rel="noopener">http://hub-mirror.c.163.com。</a><br>在任务栏点击 Docker for mac 应用图标 -&gt; Preferences… -&gt; Daemon -&gt; Registry mirrors。在列表中填写加速器地址即可。修改完成之后，点击 Apply &amp; Restart 按钮，Docker 就会重启并应用配置的镜像地址了。</p><h1 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h1><ol><li>查看应用容器 <code>docker ps</code></li><li>启动一个容器 <code>docker run -d -p 5000:5000 training/webapp python app.py</code></li><li>查看应用日志 <code>docker logs -f 7a38a1ad55c6</code></li><li>查看应用程序容器的进程 <code>docker top 镜像名</code></li><li>检查应用程序 <code>docker inspect 镜像名</code></li><li>停止应用容器 <code>docker stop 镜像名</code></li><li>移除应用容器 <code>docker rm 镜像名</code></li><li>查看镜像列表 <code>docker image</code></li><li>获取一个新镜像 <code>docker pull image:tag</code></li><li>查找镜像 <code>docker search httpd</code></li><li>构建镜像 <code>docker build -t image:tag .</code></li><li>设置镜像tag <code>docker tag 860c279d2fec image:tag</code></li></ol><h1 id="docker学习资源"><a href="#docker学习资源" class="headerlink" title="docker学习资源"></a>docker学习资源</h1><p><a href="http://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">http://www.runoob.com/docker/docker-command-manual.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker是一个简化部署的容器,使用docker不仅能够降低性能消耗，而且方便部署工作，在互联网企业中使用十分普遍。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="https://blog.xiaomo.info/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="容器" scheme="https://blog.xiaomo.info/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>jdk源码系列-Java中ArrayList、LinkedList和Vector的联系与区别</title>
    <link href="https://blog.xiaomo.info/2018/jdkSourceCodeReadArrayListAndLinkedArrayList/"/>
    <id>https://blog.xiaomo.info/2018/jdkSourceCodeReadArrayListAndLinkedArrayList/</id>
    <published>2018-06-11T00:00:00.000Z</published>
    <updated>2020-06-28T16:53:07.139Z</updated>
    
    <content type="html"><![CDATA[<p>毫无疑问，List是一种非常基础的数据结构，翻译过来就是列表。正如它的名字所示，List表示的是一个有序(插入顺序)的元素序列。在Java的集合框架中，List是作为顶级接口Collection的直接子类接口存在，因此，List分支是集合框架中最简单、最常用的分支。<br><a id="more"></a></p><h1 id="List概述"><a href="#List概述" class="headerlink" title="List概述"></a>List概述</h1><p>List分支作为集合框架中最简单、最常用的分支，其在集合框架中的位置可以直接参看下图：<br><img src="https://image.xiaomo.info/blog/linkedArraylist.jpg" alt></p><p>仔细观察和分析此图，你会发现JDK中对于List接口的实现由三种类型：ArrayList、Vector 和 LinkedList。当我们谈论List的时候，我们可以用它与Set来做比较，集合框架中的Set代表一群无序和唯一的元素集合。<br>仔细观察上图可知，集合框架中的List接口具有多达三个实现类。由继承机制可知，它们在很多方面都是非常相似的，比如有序、用法等。它们之间最大的区别是它们的内部实现方式和细节，不同的实现方式和细节造就了它们之间巨大的性能差异和用法差异。</p><ol><li>ArrayList 是Java语言对于动态数组的一个实现。当不断地添加新的元素到ArrayList集合中时，该集合的底层数组的长度就会动态的增长，以便能容纳新添加的元素。至于ArrayList的底层数组长度的动态增长策略，在不同的JDK实现和版本中是不同的，最常见的策略是新增 %50，具体请参看源码。正因为ArrayList的底层实现是数组，其带来的一个特性是：它的元素可以通过 getter(index) 和 setter(index) 方法直接访问，而且性能特别好。</li><li>LinkedList 的底层实现是基于 双向队列(double linked list)。熟悉数据结构的读者应该可以猜到：LinkedList 对于新增和删除元素的操作在性能上远远优于 ArrayList。但是，它的缺点在于：其 getter(index) 方法和 setter(index) 方法的性能很差，时间复杂度是 O(n)。</li><li>Vector 与 ArrayList 唯一的区别是：它是同步的(synchronized)，线程安全。</li></ol><h1 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h1><ol><li>对于ArrayList，add/remove的时间复杂度是 O(n)；但在尾部操作是 O(1) 。</li><li>对于LinkedList，add/remove的时间复杂度是 O(n)；但在尾部和头部操作的是 O(1) 。</li></ol><h1 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h1><p>为了实际测验三种List的add、get和remove的性能，我们可以使用如下的代码片段：</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">arrayList.<span class="keyword">add</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line"><span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"duration : "</span> + duration);</span><br></pre></td></tr></table></figure><p>此处只给出测验ArrayList的add操作的代码，但是测验LinkedList和其他操作的代码是类似，读者可自行修改代码进行测验。测验的结果表明：<br>在add和remove操作时，LinkedList的性能远优于ArrayList。在get操作时，ArrayList的性能优于LinkedList。经过性能对比和性能的测试，我们可以总结出如何在它们之间做出选择。通常使用ArrayList，但是LinkedList在如下场景时更合适：</p><ol><li>随机访问集合元素的次数不是很频繁。</li><li>对集合有大量的add/remove操作需求。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对比Vector和ArrayList，如果程序本身就是线程安全的，为了更好的性能，应该选择ArrayList。当添加新的元素到集合时，Vector和ArrayList都需要更多的空间来存储新元素，但是它们的增长策略是不一样的：Vector的增长幅度是 100%；ArrayList的增长幅度是 50%。对于LinkdedList而言，其不仅实现了List接口，还实现了Queue接口，这个Queue接口给LinkdedList带来了更多的访问和操作元素的方法，比如 offer(), peek(), poll() 等。<br>对于ArrayList而言，如果使用不含参数的构造函数新建一个ArrayList对象，该对象的起始大小是比较小的，只有10。我们都知道对象的动态增长导致的底层数组重写分配和复制是一个非常耗时的操作。所以，对于可以预估ArrayList大小的应用场景，应该指定ArrayList对象的初始大小，从而提供性能。</p><h1 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h1><p><a href="http://www.tiantianbianma.com/java-arraylist-linkedlist-vector.html/" target="_blank" rel="noopener">Java中ArrayList、LinkedList和Vector的联系与区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;毫无疑问，List是一种非常基础的数据结构，翻译过来就是列表。正如它的名字所示，List表示的是一个有序(插入顺序)的元素序列。在Java的集合框架中，List是作为顶级接口Collection的直接子类接口存在，因此，List分支是集合框架中最简单、最常用的分支。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://blog.xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://blog.xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>jdk源码系列-String,StringBuffer,StringBuilder</title>
    <link href="https://blog.xiaomo.info/2018/jdkSourceCodeReadStringDifferent/"/>
    <id>https://blog.xiaomo.info/2018/jdkSourceCodeReadStringDifferent/</id>
    <published>2018-06-09T00:00:00.000Z</published>
    <updated>2020-06-28T16:53:07.139Z</updated>
    
    <content type="html"><![CDATA[<p>String,StringBuilder以及StringBuffer这三个类之间有什么区别?<br><a id="more"></a></p><p>这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面。</p><p>首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String<br>String最慢的原因：<br>String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。以下面一段代码为例：</p><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span>=<span class="string">"abc"</span>;</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line"><span class="built_in">str</span>=<span class="built_in">str</span>+<span class="string">"de"</span>;</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br></pre></td></tr></table></figure><p>　如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。另外，有时候我们会这样对字符串进行赋值</p><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span>=<span class="string">"abc"</span>+<span class="string">"de"</span>;</span><br><span class="line">StringBuilder stringBuilder=<span class="keyword">new</span> StringBuilder().<span class="built_in">append</span>(<span class="string">"abc"</span>).<span class="built_in">append</span>(<span class="string">"de"</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(stringBuilder.toString());</span><br></pre></td></tr></table></figure><p>这样输出结果也是“abcde”和“abcde”，但是String的速度却比StringBuilder的反应速度要快很多，这是因为第1行中的操作和<code>String str=&quot;abcde&quot;;</code>是完全一样的，所以会很快，而如果写成下面这种形式</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">String <span class="attribute">str1</span>=<span class="string">"abc"</span>;</span><br><span class="line">String <span class="attribute">str2</span>=<span class="string">"de"</span>;</span><br><span class="line">String <span class="attribute">str</span>=str1+str2;</span><br></pre></td></tr></table></figure><p>那么JVM就会像上面说的那样，不断的创建、回收对象来进行这个操作了。速度就会很慢。</p><ol start="2"><li><p>再来说线程安全<br>在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的<br>如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。</p></li><li><p>总结一下<br>String：适用于少量的字符串操作的情况<br>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况<br>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p></li></ol><h1 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h1><p><a href="https://www.cnblogs.com/su-feng/p/6659064.html" target="_blank" rel="noopener">Java中的String，StringBuilder，StringBuffer三者的区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;String,StringBuilder以及StringBuffer这三个类之间有什么区别?&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://blog.xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://blog.xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>jdk源码系列-类的初始化顺序</title>
    <link href="https://blog.xiaomo.info/2018/jdkSourceCodeReadClassInitOrder/"/>
    <id>https://blog.xiaomo.info/2018/jdkSourceCodeReadClassInitOrder/</id>
    <published>2018-06-09T00:00:00.000Z</published>
    <updated>2020-06-28T16:53:07.139Z</updated>
    
    <content type="html"><![CDATA[<p>大家在去参加面试的时候，经常会遇到这样的考题：给你两个类的代码，它们之间是继承的关系，每个类里只有构造器方法和一些变量，构造器里可能还有一段代码对变量值进行了某种运算，另外还有一些将变量值输出到控制台的代码，然后让我们判断输出的结果。这实际上是在考查我们对于继承情况下类的初始化顺序的了解<br><a id="more"></a><br>我们大家都知道，对于静态变量、静态初始化块、变量、初始化块、构造器，它们的初始化顺序依次是（静态变量、静态初始化块）&gt;（变量、初始化块）&gt;构造器。我们也可以通过下面的测试代码来验证这一点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitialOrderTest</span> </span>&#123;</span><br><span class="line"><span class="comment">// 静态变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String staticField = <span class="string">"静态变量"</span>;</span><br><span class="line"><span class="comment">// 变量</span></span><br><span class="line"><span class="keyword">public</span> String field = <span class="string">"变量"</span>;</span><br><span class="line"><span class="comment">// 静态初始化块</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(staticField);</span><br><span class="line">    System.out.println(<span class="string">"静态初始化块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化块</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(field);</span><br><span class="line">    System.out.println(<span class="string">"初始化块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InitialOrderTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"构造器"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> InitialOrderTest();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上代码，我们会得到如下的输出结果：</p><ol><li>静态变量</li><li>静态初始化块</li><li>变量</li><li>初始化块</li><li>构造器</li></ol><p>这与上文中说的完全符合。那么对于继承情况下又会怎样呢？我们仍然以一段测试代码来获取最终结果:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"><span class="comment">// 静态变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String p_StaticField = <span class="string">"父类--静态变量"</span>;</span><br><span class="line"><span class="comment">// 变量</span></span><br><span class="line"><span class="keyword">public</span> String p_Field = <span class="string">"父类--变量"</span>;</span><br><span class="line"><span class="comment">// 静态初始化块</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(p_StaticField);</span><br><span class="line">    System.out.println(<span class="string">"父类--静态初始化块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化块</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(p_Field);</span><br><span class="line">    System.out.println(<span class="string">"父类--初始化块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line">    &#123;</span><br><span class="line">    System.out.println(<span class="string">"父类--构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"><span class="comment">// 静态变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String s_StaticField = <span class="string">"子类--静态变量"</span>;</span><br><span class="line"><span class="comment">// 变量</span></span><br><span class="line"><span class="keyword">public</span> String s_Field = <span class="string">"子类--变量"</span>;</span><br><span class="line"><span class="comment">// 静态初始化块</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(s_StaticField);</span><br><span class="line">    System.out.println(<span class="string">"子类--静态初始化块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化块</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(s_Field);</span><br><span class="line">    System.out.println(<span class="string">"子类--初始化块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"子类--构造器"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序入口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> SubClass();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下上面的代码，结果马上呈现在我们的眼前：</p><ol><li>父类–静态变量</li><li>父类–静态初始化块</li><li>子类–静态变量</li><li>子类–静态初始化块</li><li>父类–变量</li><li>父类–初始化块</li><li>父类–构造器</li><li>子类–变量</li><li>子类–初始化块</li><li>子类–构造器</li></ol><p>现在，结果已经不言自明了。大家可能会注意到一点，那就是，并不是父类完全初始化完毕后才进行子类的初始化，实际上子类的静态变量和静态初始化块的初始化是在父类的变量、初始化块和构造器初始化之前就完成了。<br>那么对于静态变量和静态初始化块之间、变量和初始化块之间的先后顺序又是怎样呢？是否静态变量总是先于静态初始化块，变量总是先于初始化块就被初始化了呢？实际上这取决于它们在类中出现的先后顺序。我们以静态变量和静态初始化块为例来进行说明。</p><p>同样，我们还是写一个类来进行测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOrder</span> </span>&#123;</span><br><span class="line"><span class="comment">// 静态变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TestA a = <span class="keyword">new</span> TestA();</span><br><span class="line"><span class="comment">// 静态初始化块</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"静态初始化块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TestB b = <span class="keyword">new</span> TestB();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> TestOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test--A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test--B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的代码，会得到如下的结果：</p><ol><li>Test–A</li><li>静态初始化块</li><li>Test–B</li></ol><p>大家可以随意改变变量a、变量b以及静态初始化块的前后位置，就会发现输出结果随着它们在类中出现的前后顺序而改变，这就说明静态变量和静态初始化块是依照他们在类中的定义顺序进行初始化的。同样，变量和初始化块也遵循这个规律。了解了继承情况下类的初始化顺序之后，如何判断最终输出结果就迎刃而解了</p><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p>转载自 臧圩人 <a href="http://zangweiren.javaeye.com" target="_blank" rel="noopener">http://zangweiren.javaeye.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家在去参加面试的时候，经常会遇到这样的考题：给你两个类的代码，它们之间是继承的关系，每个类里只有构造器方法和一些变量，构造器里可能还有一段代码对变量值进行了某种运算，另外还有一些将变量值输出到控制台的代码，然后让我们判断输出的结果。这实际上是在考查我们对于继承情况下类的初始化顺序的了解&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://blog.xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://blog.xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>jdk源码系列-创建对象</title>
    <link href="https://blog.xiaomo.info/2018/jdkSourceCodeReadCreateObject/"/>
    <id>https://blog.xiaomo.info/2018/jdkSourceCodeReadCreateObject/</id>
    <published>2018-06-09T00:00:00.000Z</published>
    <updated>2020-06-28T16:53:07.139Z</updated>
    
    <content type="html"><![CDATA[<p><code>String str=new String(&quot;abc&quot;);</code>到底创建了几个对象？相信大家对这此并不陌生，答案也是众所周知的，2个。接下来我们就从这道题展开，一起回顾一下与创建String对象相关的一些JAVA知识。<br><a id="more"></a></p><h1 id="String-str-new-String-quot-abc-quot"><a href="#String-str-new-String-quot-abc-quot" class="headerlink" title="String str=new String(&quot;abc&quot;);"></a><code>String str=new String(&quot;abc&quot;);</code></h1><p>我们可以把上面这行代码分成String str、=、”abc”和new String()四部分来看待。String str只是定义了一个名为str的String类型的变量，因此它并没有创建对象；=是对变量str进行初始化，将某个对象的引用（或者叫句柄）赋值给它，显然也没有创建对象；现在只剩下new String(“abc”)了。那么，new String(“abc”)为什么又能被看成”abc”和new String()呢？我们来看一下被我们调用了的String的构造器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//other code ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家都知道，我们常用的创建一个类的实例（对象）的方法有以下两种：</p><ol><li>使用new创建对象。</li><li>调用Class类的newInstance方法，利用反射机制创建对象。<br>我们正是使用new调用了String类的上面那个构造器方法创建了一个对象，并将它的引用赋值给了str变量。同时我们注意到，被调用的构造器方法接受的参数也是一个String对象，这个对象正是”abc”。由此我们又要引入另外一种创建String对象的方式的讨论——引号内包含文本。这种方式是String特有的，并且它与new的方式存在很大区别</li></ol><h1 id="String-str-quot-abc-quot"><a href="#String-str-quot-abc-quot" class="headerlink" title="String str=&quot;abc&quot;;"></a><code>String str=&quot;abc&quot;;</code></h1><p>毫无疑问，这行代码创建了一个String对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    String a=<span class="string">"abc"</span>;</span><br><span class="line">    String b=<span class="string">"abc"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那这里呢？答案还是一个。</p><p><code>String a=&quot;ab&quot;+&quot;cd&quot;;</code><br>再看看这里呢？答案仍是一个。有点奇怪吗？说到这里，我们就需要引入对字符串池相关知识的回顾了。</p><p>在JAVA虚拟机（JVM）中存在着一个字符串池，其中保存着很多String对象，并且可以被共享使用，因此它提高了效率。由于String类是final的，它的值一经创建就不可改变，因此我们不用担心String对象共享而带来程序的混乱。字符串池由String类维护，我们可以调用intern()方法来访问字符串池。我们再回头看看String a=”abc”;，这行代码被执行的时候，JAVA虚拟机首先在字符串池中查找是否已经存在了值为”abc”的这么一个对象，它的判断依据是String类equals(Object obj)方法的返回值。如果有，则不再创建新的对象，直接返回已存在对象的引用；如果没有，则先创建这个对象，然后把它加入到字符串池中，再将它的引用返回。因此，我们不难理解前面三个例子中头两个例子为什么是这个答案了。<br>对于第三个例子：<br>String a=”ab”+”cd”;<br>由于常量的值在编译的时候就被确定了。在这里，”ab”和”cd”都是常量，因此变量a的值在编译时就可以确定。</p><p>这行代码编译后的效果等同于：<br>String a=”abcd”;<br>因此这里只创建了一个对象”abcd”，并且它被保存在字符串池里了。现在问题又来了，是不是所有经过“+”连接后得到的字符串都会被添加到字符串池中呢？我们都知道“==”</p><p>可以用来比较两个变量，它有以下两种情况：</p><ol><li>如果比较的是两个基本类型（char，byte，short，int，long，float，double，boolean），则是判断它们的值是否相等。</li><li>如果表较的是两个对象变量，则是判断它们的引用是否指向同一个对象。</li></ol><p>下面我们就用“==”来做几个测试。为了便于说明，我们把指向字符串池中已经存在的对象也视为该对象被加入了字符串池：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String a = <span class="string">"ab"</span>;<span class="comment">// 创建了一个对象，并加入字符串池中</span></span><br><span class="line">System.out.println(<span class="string">"String a = \"ab\";"</span>);</span><br><span class="line">String b = <span class="string">"cd"</span>;<span class="comment">// 创建了一个对象，并加入字符串池中</span></span><br><span class="line">System.out.println(<span class="string">"String b = \"cd\";"</span>);</span><br><span class="line">String c = <span class="string">"abcd"</span>;<span class="comment">// 创建了一个对象，并加入字符串池中</span></span><br><span class="line">String d = <span class="string">"ab"</span> + <span class="string">"cd"</span>;</span><br><span class="line"><span class="comment">// 如果d和c指向了同一个对象，则说明d也被加入了字符串池</span></span><br><span class="line"><span class="keyword">if</span> (d == c) &#123;</span><br><span class="line">    System.out.println(<span class="string">"\"ab\"+\"cd\" 创建的对象 \"加入了\" 字符串池中"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果d和c没有指向了同一个对象，则说明d没有被加入字符串池</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"\"ab\"+\"cd\" 创建的对象 \"没加入\" 字符串池中"</span>);</span><br><span class="line">&#125;</span><br><span class="line">String e = a + <span class="string">"cd"</span>;</span><br><span class="line"><span class="comment">// 如果e和c指向了同一个对象，则说明e也被加入了字符串池</span></span><br><span class="line"><span class="keyword">if</span> (e == c) &#123;</span><br><span class="line">    System.out.println(<span class="string">" a +\"cd\" 创建的对象 \"加入了\" 字符串池中"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果e和c没有指向了同一个对象，则说明e没有被加入字符串池</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">" a +\"cd\" 创建的对象 \"没加入\" 字符串池中"</span>);</span><br><span class="line">&#125;</span><br><span class="line">String f = <span class="string">"ab"</span> + b;</span><br><span class="line"><span class="comment">// 如果f和c指向了同一个对象，则说明f也被加入了字符串池</span></span><br><span class="line"><span class="keyword">if</span> (f == c) &#123;</span><br><span class="line">    System.out.println(<span class="string">"\"ab\"+ b 创建的对象 \"加入了\" 字符串池中"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果f和c没有指向了同一个对象，则说明f没有被加入字符串池</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"\"ab\"+ b 创建的对象 \"没加入\" 字符串池中"</span>);</span><br><span class="line">&#125;</span><br><span class="line">String g = a + b;</span><br><span class="line"><span class="comment">// 如果g和c指向了同一个对象，则说明g也被加入了字符串池</span></span><br><span class="line"><span class="keyword">if</span> (g == c) &#123;</span><br><span class="line">    System.out.println(<span class="string">" a + b 创建的对象 \"加入了\" 字符串池中"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果g和c没有指向了同一个对象，则说明g没有被加入字符串池</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">" a + b 创建的对象 \"没加入\" 字符串池中"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><ol><li>String a = “ab”;</li><li>String b = “cd”;</li><li>“ab”+”cd” 创建的对象 “加入了” 字符串池中</li><li>a +”cd” 创建的对象 “没加入” 字符串池中</li><li>“ab”+ b 创建的对象 “没加入” 字符串池中</li><li>a + b 创建的对象 “没加入” 字符串池中</li></ol><p>从上面的结果中我们不难看出，只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中，对此我们不再赘述</p><p>但是有一种情况需要引起我们的注意。请看下面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringStaticTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 常量A</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String A = <span class="string">"ab"</span>;</span><br><span class="line">    <span class="comment">// 常量B</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String B = <span class="string">"cd"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将两个常量用+连接对s进行初始化</span></span><br><span class="line">    String s = A + B;</span><br><span class="line">    String t = <span class="string">"abcd"</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">        System.out.println(<span class="string">"s等于t，它们是同一个对象"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"s不等于t，它们不是同一个对象"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的运行结果如下：</p><ul><li>s等于t，它们是同一个对象</li></ul><p>这又是为什么呢？原因是这样的，对于常量来讲，它的值是固定的，因此在编译期就能被确定了，而变量的值只有到运行时才能被确定，因为这个变量可以被不同的方法调用，从而可能引起值的改变。在上面的例子中，A和B都是常量，值是固定的，因此s的值也是固定的，它在类被编译时就已经确定了。也就是说：</p><p><code>String s=A+B;</code> 等同于<code>String s=&quot;ab&quot;+&quot;cd&quot;;</code></p><p>我对上面的例子稍加改变看看会出现什么情况：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringStaticTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 常量A</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String A;</span><br><span class="line">    <span class="comment">// 常量B</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String B;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    A = <span class="string">"ab"</span>;</span><br><span class="line">    B = <span class="string">"cd"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将两个常量用+连接对s进行初始化</span></span><br><span class="line">    String s = A + B;</span><br><span class="line">    String t = <span class="string">"abcd"</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">        System.out.println(<span class="string">"s等于t，它们是同一个对象"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"s不等于t，它们不是同一个对象"</span>);</span><br><span class="line">     &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的运行结果是这样：</p><ul><li>s不等于t，它们不是同一个对象<br>只是做了一点改动，结果就和刚刚的例子恰好相反。我们再来分析一下。A和B虽然被定义为常量（只能被赋值一次），但是它们都没有马上被赋值。在运算出s的值之前，他们何时被赋值，以及被赋予什么样的值，都是个变数。因此A和B在被赋值之前，性质类似于一个变量。那么s就不能在编译期被确定，而只能在运行时被创建了。由于字符串池中对象的共享能够带来效率的提高，因此我们提倡大家用引号包含文本的方式来创建String对象，实际上这也是我们在编程中常采用的。<br>接下来我们再来看看intern()方法，它的定义如下：<br><code>public native String intern();</code></li></ul><p>这是一个本地方法。在调用这个方法时，JAVA虚拟机首先检查字符串池中是否已经存在与该对象值相等对象存在，如果有则返回字符串池中对象的引用；如果没有，则先在字符串池中创建一个相同值的String对象，然后再将它的引用返回。</p><p>我们来看这段代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringInternTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用char数组来初始化a，避免在a被创建之前字符串池中已经存在了值为"abcd"的对象</span></span><br><span class="line">    String a = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[] &#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span> &#125;);</span><br><span class="line">    String b = a.intern();</span><br><span class="line">    <span class="keyword">if</span> (b == a) &#123;</span><br><span class="line">        System.out.println(<span class="string">"b被加入了字符串池中，没有新建对象"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"b没被加入字符串池中，新建了对象"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>b没被加入字符串池中，新建了对象。如果String类的intern()方法在没有找到相同值的对象时，是把当前对象加入字符串池中，然后返回它的引用的话，那么b和a指向的就是同一个对象；否则b指向的对象就是JAVA虚拟机在字符串池中新建的，只是它的值与a相同罢了。上面这段代码的运行结果恰恰印证了这一点。最后我们再来说说String对象在JAVA虚拟机（JVM）中的存储，以及字符串池与堆（heap）和栈（stack）的关系。我们首先回顾一下堆和栈的区别：</p><p>• 栈（stack）：主要保存基本类型（或者叫内置类型）（char、byte、short、int、long、float、double、boolean）和对象的引用，数据可以共享，速度仅次于寄存器（register），快于堆。<br>• 堆（heap）：用于存储对象。</p><p>我们查看String类的源码就会发现，它有一个value属性，保存着String对象的值，类型是char[]，这也正说明了字符串就是字符的序列。当执行String a=”abc”;时，JAVA虚拟机会在栈中创建三个char型的值’a’、’b’和’c’，然后在堆中创建一个String对象，它的值（value）是刚才在栈中创建的三个char型值组成的数组{‘a’,’b’,’c’}，最后这个新创建的String对象会被添加到字符串池中。如果我们接着执行String b=new String(“abc”);代码，由于”abc”已经被创建并保存于字符串池中，因此JAVA虚拟机只会在堆中新创建一个String对象，但是它的值（value）是共享前一行代码执行时在栈中创建的三个char型值值’a’、’b’和’c’。说到这里，我们对于篇首提出的String str=new String(“abc”)为什么是创建了两个对象这个问题就已经相当明了了</p><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p>转载自 臧圩人 <a href="http://zangweiren.javaeye.com" target="_blank" rel="noopener">http://zangweiren.javaeye.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;String str=new String(&amp;quot;abc&amp;quot;);&lt;/code&gt;到底创建了几个对象？相信大家对这此并不陌生，答案也是众所周知的，2个。接下来我们就从这道题展开，一起回顾一下与创建String对象相关的一些JAVA知识。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://blog.xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://blog.xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>jdk源码系列-线程池</title>
    <link href="https://blog.xiaomo.info/2018/jdkSourceCodeReadThreadPool/"/>
    <id>https://blog.xiaomo.info/2018/jdkSourceCodeReadThreadPool/</id>
    <published>2018-06-02T00:00:00.000Z</published>
    <updated>2020-06-28T16:53:07.139Z</updated>
    
    <content type="html"><![CDATA[<p>Executors 是 Executor、ExecutorService、ThreadFactory、Callable 类的工厂和工具方法。<br><a id="more"></a></p><h1 id="创建一个固定大小的线程池"><a href="#创建一个固定大小的线程池" class="headerlink" title="创建一个固定大小的线程池"></a>创建一个固定大小的线程池</h1><p>通过重用共享无界队列里的线程来减少线程创建的开销。当所有的线程都在执行任务，新增的任务将会在队列中等待，直到一个线程空闲。由于在执行前失败导致的线程中断，如果需要继续执行接下去的任务，新的线程会取代它执行。线程池中的线程会一直存在，除非明确地 shutdown 掉。</p><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads) &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="number">0</span>L, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的是 ThreadPoolExecutor 类的对象，这个构造方法使用传入的参数和默认的线程工厂与拒绝执行的处理。<br>corePoolSize：线程池中的线程数量，除非设置了 allowCoreThreadTimeOut， 否则就算线程空闲还是在保存在线程池中<br>maximumPoolSize：线程池中允许存放最大的线程数量<br>keepAliveTime：当线程数大于 corePoolSize，如果 keepAliveTime 内空闲的线程未执行，线程将被终结<br>unit：keepAliveTime 的时间单位<br>workQueue：保存 execute() 提交的任务 </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,  </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,  </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,  </span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,  </span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,  </span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到固定大小线程池，corePoolSize 和 maximumPoolSize 传入的参数是一样的</p><h1 id="创建一个单个线程的线程池"><a href="#创建一个单个线程的线程池" class="headerlink" title="创建一个单个线程的线程池"></a>创建一个单个线程的线程池</h1><p>任务会被保证顺序执行，因为只有一个工作线程。不像 newFixedThreadPool(1)，这个不保证任务顺序执行。corePoolSize 和 maximumPoolSize 都是 1。</p><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>() &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FinalizableDelegatedExecutorService</span>  </span><br><span class="line">        (<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0</span>L, TimeUnit.MILLISECONDS,<span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;()));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="创建一个可按需自动扩容的线程池-但是会优先重用线程池中空闲可用的线程"><a href="#创建一个可按需自动扩容的线程池-但是会优先重用线程池中空闲可用的线程" class="headerlink" title="创建一个可按需自动扩容的线程池,但是会优先重用线程池中空闲可用的线程"></a>创建一个可按需自动扩容的线程池,但是会优先重用线程池中空闲可用的线程</h1><p>这个类型的线程池将会大大提升执行许多短暂的异步任务的程序。如果线程池中线程都在使用，又有新任务到来，则新增一个线程到线程池。如果线程 60 秒内空闲，则将被终止移除线程池。corePoolSize 为 0，可知一旦线程 60s 空闲就会被移出线程池</p><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>() &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,<span class="number">60</span>L, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="创建一个在一定延迟时间后调度命令的线程池，或者周期性执行的线程池。"><a href="#创建一个在一定延迟时间后调度命令的线程池，或者周期性执行的线程池。" class="headerlink" title="创建一个在一定延迟时间后调度命令的线程池，或者周期性执行的线程池。"></a>创建一个在一定延迟时间后调度命令的线程池，或者周期性执行的线程池。</h1><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="keyword">new</span><span class="type">ScheduledThreadPool</span>(int corePoolSize) &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ScheduledThreadPoolExecutor</span>(corePoolSize);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="创建完线程池，然后就该执行任务了"><a href="#创建完线程池，然后就该执行任务了" class="headerlink" title="创建完线程池，然后就该执行任务了"></a>创建完线程池，然后就该执行任务了</h1><p>看下内部类 DelegatedExecutorService 里的 execute 方法：可以看到任务执行策略（单线程串行、多线程并行）和任务的具体执行分离，是一个典型的命令模式。</p><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatedExecutorService</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService e;  </span><br><span class="line">    DelegatedExecutorService(ExecutorService executor) &#123; e = executor; &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123; e.execute(command); &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123; e.shutdown(); &#125;  </span><br><span class="line">    <span class="keyword">public</span> List&lt;Runnable&gt; shutdownNow() &#123; <span class="function"><span class="keyword">return</span> e.<span class="title">shutdownNow</span><span class="params">()</span></span>; &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span> </span>&#123; <span class="function"><span class="keyword">return</span> e.<span class="title">isShutdown</span><span class="params">()</span></span>; &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span> </span>&#123; <span class="function"><span class="keyword">return</span> e.<span class="title">isTerminated</span><span class="params">()</span></span>; &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> awaitTermination(<span class="keyword">long</span> timeout, TimeUnit unit)  </span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">return</span> e.<span class="title">awaitTermination</span><span class="params">(timeout, unit)</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">return</span> e.<span class="title">submit</span><span class="params">(task)</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">return</span> e.<span class="title">submit</span><span class="params">(task)</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">return</span> e.<span class="title">submit</span><span class="params">(task, result)</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? <span class="keyword">extends</span> Callable&lt;T&gt;&gt; tasks)  </span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">return</span> e.<span class="title">invokeAll</span><span class="params">(tasks)</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? <span class="keyword">extends</span> Callable&lt;T&gt;&gt; tasks,  </span><br><span class="line">                                         <span class="keyword">long</span> timeout, TimeUnit unit)  </span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">return</span> e.<span class="title">invokeAll</span><span class="params">(tasks, timeout, unit)</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T invokeAny(Collection&lt;? <span class="keyword">extends</span> Callable&lt;T&gt;&gt; tasks)  </span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">return</span> e.<span class="title">invokeAny</span><span class="params">(tasks)</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T invokeAny(Collection&lt;? <span class="keyword">extends</span> Callable&lt;T&gt;&gt; tasks,  </span><br><span class="line">                           <span class="keyword">long</span> timeout, TimeUnit unit)  </span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">return</span> e.<span class="title">invokeAny</span><span class="params">(tasks, timeout, unit)</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建线程池的时候，已经实例化了 ThreadPoolExecutor，所以上面 execute() 方法实际是调用 ThreadPoolExecutor 的 execute：给定的任务可能在未来的某个时刻执行。可能是新建一个线程执行，也可能是线程中原有的线程执行。如果任务不能执行，可能是这个 executor 已经被 shutdown 了，也可能是到达了线程池的执行阈值，任务被拒绝执行处理器处理中。</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="params">Runnable command</span>)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">    <span class="keyword">int</span> c = ctl.<span class="keyword">get</span>();  </span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        c = ctl.<span class="keyword">get</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;  </span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.<span class="keyword">get</span>();  </span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; <span class="keyword">remove</span>(command))  </span><br><span class="line">            reject(command);  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)  </span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))  </span><br><span class="line">        reject(command);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这，其实发现线程池的核心实现就是在 ThreadPoolExecutor 里面，所以先介绍下 ThreadPoolExecutor 类的作用： </p><p><img src="https://image.xiaomo.info/blog/executor.png" alt></p><p>上图可以看出 ThreadPoolExecutor 类的层次结构中的位置，是对抽象方法和接口的完整实现，即核心代码在这个类里。</p><p>一个 ExecutorService 执行每个任务可能用到线程池中的一个或多个线程，线程池由 Executors 工厂创建。<br>线程池解决了两个不同的问题：</p><ol><li>执行大量异步的任务时，线程池减少线程的创建来减少开销，提升性能</li><li>提供了对资源的管理，包括当执行一系列任务时，线程的消耗。每个 ThreadPoolExecutor 也存储有些基本数据，诸如完成的任务数量</li></ol><p>想要在更广阔的背景下使用的话，这个类提供了许多可调整的参数和扩展的 hook。不管怎么样，还是推荐使用 Executors 来创建线程池比较方便。</p><p>这个主要的线程池控制状态 ctl，使用 AtomicInteger 存储两个概念上的字段 workerCount(线程池有效的线程数) 和 runState(线程池是 running、shuting down 等等状态) </p><p><code>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</code></p><p>上述 execute() 方法有三个处理步骤：</p><ol><li>如果正在 running 的线程 (即 worker 线程) 小于 corePoolSize ( workerCountOf(c) &lt; corePoolSize )，尝试创建一个新线程并把传入的 command(任务) 作为它的第一个任务。调用 addWorker(command, true) 自动检查 runState 和 workCount，以便在不能增加线程的时候返回 false。添加成功直接 return，不能添加就要看下面的步骤</li><li>如果被成功放进队列（if (isRunning(c) &amp;&amp; workQueue.offer(command))  workQueue 是一个任务排队的阻塞队列），然后还需要二次检查线程池是否 shut down（上次检查后到这次检查前死亡）。所以我们重新检查状态，如果线程池停止的话，回滚进队操作，或者如果没有工作的线程开启一个新线程（addWorker(null, false);）</li><li>如果不能让任务进入阻塞队列，然后尝试新增一个线程。如果新增线程失败，可能是线程池 shut down 或者线程池饱和（达到 maxPoolSize），所以接下来抛弃这个任务。</li></ol><p>任务（Task）被包装在一个叫做 Worker 的内部类，Worker 继承 AQS 来实现任务增加/删除的同步控制，使用 HashSet 来保存 Worker 线程。如果 worker 线程大于 corePoolSize，则不创建 worker 线程，而是放入一个 BlockingQueue 排队。如果有界队列的 BlockingQueue 满了，则尝试增加线程到线程池，但是线程总数要小于 maxPollSize。</p><p>addWorker() 方法：检查线程池当前状态和线程数量的边界条件看是否可以增加 worker 线程。如果可以，工作线程计数响应调整，并且，如果可能的话，新的 worker 线程被创建，启动，跑它的第一个 task。如果线程池 stop 或者要被 shut down，此方法返回 false。如果线程工厂（thread factory）创建线程失败，此方法也会返回 false。如果线程创建失败，不管是 thread factory 返回 null，或者 exception（通常是 OOM），都会被回滚。</p><p>参数<br>firstTask： 新线程应该运行的第一个任务。如果 worker 线程小于 corePoolSize，worker 和初始化的第一次任务一起创建绕过排队这一过程，或者队列已满。初始化空闲线程通常是通过 prestartCoreThread 或者替换已经死亡的 worker 线程。<br>core：如果 true，则使用 corePoolSize 作为边界，否则使用 maximumPoolSize 作为边界。（这里使用 Boolean 而不是传入实际值，是因为传入值可能会在传入过程被改变，在方法中直接读取值更精确）。  </p><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">boolean</span> addWorker(Runnable firstTask, <span class="built_in">boolean</span> core) &#123;  </span><br><span class="line">    retry:  </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">        <span class="built_in">int</span> c = ctl.<span class="built_in">get</span>();  </span><br><span class="line">        <span class="built_in">int</span> rs = runStateOf(c);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.  </span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;  </span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;  </span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;  </span><br><span class="line">               ! workQueue.isEmpty()))  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">            <span class="built_in">int</span> wc = workerCountOf(c);  </span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||  </span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))  </span><br><span class="line">                <span class="keyword">break</span> retry;  </span><br><span class="line">            c = ctl.<span class="built_in">get</span>();  <span class="comment">// Re-read ctl  </span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)  </span><br><span class="line">                <span class="keyword">continue</span> retry;  </span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">boolean</span> workerStarted = <span class="keyword">false</span>;  </span><br><span class="line">    <span class="built_in">boolean</span> workerAdded = <span class="keyword">false</span>;  </span><br><span class="line">    Worker w = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;  </span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);  </span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;  </span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            mainLock.lock();  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="comment">// Recheck while holding lock.  </span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if  </span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.  </span></span><br><span class="line">                <span class="built_in">int</span> c = ctl.<span class="built_in">get</span>();  </span><br><span class="line">                <span class="built_in">int</span> rs = runStateOf(c);  </span><br><span class="line">  </span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||  </span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable  </span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();  </span><br><span class="line">                    workers.<span class="built_in">add</span>(w);  </span><br><span class="line">                    <span class="built_in">int</span> s = workers.<span class="built_in">size</span>();  </span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)  </span><br><span class="line">                        largestPoolSize = s;  </span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">                mainLock.unlock();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;  </span><br><span class="line">                t.start();  </span><br><span class="line">                workerStarted = <span class="keyword">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)  </span><br><span class="line">            addWorkerFailed(w);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> workerStarted;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h1><p><a href="https://blog.csdn.net/wenniuwuren" target="_blank" rel="noopener">wenniuwuren</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Executors 是 Executor、ExecutorService、ThreadFactory、Callable 类的工厂和工具方法。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://blog.xiaomo.info/categories/java/"/>
    
    
      <category term="jdk源码系列" scheme="https://blog.xiaomo.info/tags/jdk%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
</feed>
